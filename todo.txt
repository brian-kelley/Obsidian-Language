---------------------
      TODO:
---------------------
-Allow subroutine overloading
-This is so that calling with union argument(s) will dynamic dispatch to the correct version for contents IF version taking exact union directly doesn't exist
  -To find matching subr, take first found where arguments exactly match,
  then where arguments are convertible
  (if none, or not all union options covered,
  error as no matching subroutine to call like C++)

-Metaprogramming:
  -Statements/variables/declarations preceded by single '#'
  Example: generate a loop that does b 10 times
  //emit is a special proc that outputs code
  #proc void do10(Block b)
  {
    emit("for i : 0,10 ");
    emit(b);
  }

  #do10({print("Hello world\n");})

  -Parser works through a single, linear token stream
  -If at any point the parser looks ahead to '#', parse a meta-statement there
  -In this context, statements can be declarations or actions

-Front end: text stream -> token stream -> parse tree
-Middle end: parse tree -> fully typed and semantically checked intermediate representation
-Meta-interpreter: IR -> more program source and parse tree nodes to be inserted
  -emitted text needs to be fed into front and middle
  -emitted parse nodes only need middle
-Run different (pre-backend) compiler stages as a pipeline instead of distinct steps as is done now
  -Allow for inserting program text at the start of stream without actually modifying original code string (performance)
  -this means that meta-stuff requires all types/subroutines to be declared before use (no good way around this?)
    -can't just leave it as deferred, because emitting code can arbitrarily affect compilation later in the source
    -if name lookup fails in the course of interpreting, immediate error

-Interoperation with arbitrary c libraries: function description is a C string that is inlined at every call site in Onyx source
  -effectively providing the body of a full C function
-Variadics not supported

-Backend: emitting control flow statements (break, continue, return) should free locals in scopes that close
  -normally, closing a block will call popScope() exactly once
  -break from loop needs to pop from innermost block up to and including the loop block
  -break from switch only pops blocks that are inside the switch
  -continue in loop pops innermost block up to but not including the loop block
  -return pops from innermost block up to and including the innermost subroutine
  -this special control flow instructions don't actually call popScope() at all, because technically those scopes
  are still open (even if the real block pop code is unreachable)

-----------------------------------
   After core language compiler:
-----------------------------------
LANGUAGE BUILT-IN MODULES (all must be fully cross-platform and absolutely need to just work:
  -Term (stdin/stdout/formatting/parsing, commands)
  -Sys (File I/O, filesystem, sockets, time)
  -Modern OpenGL (4.1+), plus some nice utilties, like:
    -GLM-style math
    -OBJ model loading
    -Shader utilities
    -Mesh utilities (half-edge structure, loading, saving)
  -Native font rendering (Unicode support, antialiasing)
  -Input (keyboard, mouse, gamepad - portable across all machines)
    -Want to be able to poll for events like SDL,
     check for button states directly, and set up callbacks
  -UI (nice libUI interface, or something similar from scratch?)
  -Native audio wrapper
  -Data structures: set(T) implemented as (T : void), binary heap
  -Compression (also use for serialization): zlib?
  -Graphs (nice data structure, Dijkstra's for single source reachability/distnace, Kosaraju's for strongly connected components, topological sort, Prim's for minimum spanning tree)
  -Support some video and audio codecs through ffmpeg

