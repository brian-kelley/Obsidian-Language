---------------------
      TODO:
---------------------
-Allow subroutine overloading
-Calling with union argument will dispatch at runtime to the correct version for runtime contents IF version taking union directly doesn't exist
  -UNLESS the subroutine is defined for the exact union
  -Look for exact matches in type, then take the first where arguments are convertible (if none, error as no matching subroutine to call like C++)

-Metaprogramming:
  -Statements/variables/declarations preceded by single '#'
  Example: generate a loop that does b 10 times
  //emit is a special proc that outputs code
  #proc void do10(Block b)
  {
    emit("for i : 0,10 ");
    emit(b);
  }

  #do10({print("Hello world\n");})

  -Parser works through a single, linear token stream
  -If at any point the parser looks ahead to '#', parse a meta-statement there
  -In this context, statements can be declarations or actions

-Lexer: text stream -> token stream
-Parser: token stream -> parse tree
-Middle end: parse tree -> middle end
-Meta-interpreter: complete middle end statements/decls -> program text and parse tree nodes through emit()
  -emitted text needs to be fed into lexer/parser/middle end
  -emitted parse nodes only need middle end
-Run different (pre-backend) compiler stages as a pipeline instead of distinct steps
  -Allow for inserting program text at the start of stream without actually modifying original code string (performance)

-Interoperation with arbitrary c libraries: function description is a C expression that is inlined at every call site in Onyx source
-Variadics not supported

-Emitting control flow statements (break, continue, return) should free locals in scopes that close
  -normally, closing a block will call popScope() exactly once
  -break from loop needs to pop from innermost block up to and including the loop block
  -break from switch only pops blocks that are inside the switch
  -continue in loop pops innermost block up to but not including the loop block
  -return pops from innermost block up to and including the innermost subroutine
  -this special control flow instructions don't actually call popScope() at all, because technically those scopes
  are still open (even if the real block pop code is unreachable)

-----------------------------------
   After core language compiler:
-----------------------------------
LANGUAGE BUILT-IN MODULES (all must be fully cross-platform and absolutely need to just work:
  -Term (stdin/stdout/formatting/parsing, commands)
  -Sys (File I/O, filesystem, sockets, time)
  -Modern OpenGL (4.1+), plus some nice utilties, like:
    -GLM-style math
    -OBJ model loading
    -Shader utilities
    -Mesh utilities (half-edge structure, loading, saving)
  -Native font rendering (Unicode support, antialiasing)
  -Input (keyboard, mouse, gamepad - portable across all machines)
    -Want to be able to poll for events like SDL,
     check for button states directly, and set up callbacks
  -UI (nice libUI interface, or something similar from scratch?)
  -Native audio wrapper
  -Data structures: set(T) implemented as (T : void), binary heap
  -Compression (also use for serialization): zlib?
  -Graphs (nice data structure, Dijkstra's for single source reachability/distnace, Kosaraju's for strongly connected components, topological sort, Prim's for minimum spanning tree)
  -Support some video and audio codecs through ffmpeg

