TODO:
---------------------
Highest priority:
-Modules can contain meta-declarations
-Meta-language simply extends off current parser, using '#' punctuation before all decls
-Compiler will parse, syntax and semantic check all meta-decls into a separate IR before any non-meta code is parsed at all
-Need to write a full, reasonably fast interpreter for the core language to process meta

---------------------

Ongoing work:
-thoroughly test lexer and parser
-Type system
  -Type struct (primitive, array, tuple, struct, variant)

***********************
| Middle end sequence |
***********************

-Create scope tree and all types and traits defined inside scopes
-For each scope, create ordered lists of variable declarations
  -search all ScopedDecls and Statements for VarDecls
-Type check: determine type of right-hand sides of all vardecls and varassigns and make sure they can be converted with canConvert()

***************
| Type system |
***************

-Need to support arrays and tuples that contain unresolved types
-New approach:
  -sweep 1 creates all named types
    -types dependent on unresolved types get added to a list (this list only needs to contain TypeNT* and Type** usage)
  -sweep 2 resolves all unresolved types in order (now, type lookup failure is an error)

IMMEDIATE SMALL TASKS:

Middle-end/Type checking
* -ScopedDecl will have pointer to enclosing Scope struct (Scope structs form a tree, traversible up and down)
  -TypeNT and Expression and ExprN will all have pointers to Type struct (which is owned by a Scope)
  -Remove ModuleDef, move decls into Module and make parseProgram return vector<AP(ScopedDecl)>
  -Module, Block, Struct will each have a ptr to their corresponding *Scope subclass
  -Rules for implicit conversion and promotion between primitives, in TypeSystem
  -Struct types: holds all semantic info (members, traits, composition)
  -Give function arguments and return values types
-Make a hash function that mangles names longer than 31 chars to 31
  -Convert last n chars to a base 62 number?
  -Debugger will need to have demangling information available at runtime

CORE LANGUAGE SUBSET:

-Semantic checker
  -Owner-member checking
  -Check that arithmetic operations are done on compatible types
  -Type checking
    -Check struct/array literals against their usage
    -Check function arguments, assignment
    -Check traits of passed values to trait arguments
  -Check that variables declared before use
    -Globals can be accessed anywhere
    -Locals can be accessed after decl in same scope
    -Locals can also be accessed in functions both declared and called after
  -Check that structs implement all functions in traits
  -Check if/while/for conditions are bools
  -Check that functions don't modify vars not declared in it
  -Passing things to trait types

-C code generation:
  In each scope:
    -First, declare all global typedefs
      -Need to manage interdependencies
    -Declare structs, tuples and variants
      -Structs and tuples are just C structs, with regular members
      -Variants are structs with a union and int containing which item is active
    -Arrays are fat-pointer types, N dimensions and just one buffer
  -Name mangler for modules, structs, nested functions
    -Struct functions take first argument T* self
  -Forward-declare all functions/procedures
  -All function definitions
    -respect nesting (top-down) but besides that order doesn't matter
  -Start standard library, for now just basic stdin and stdout

C INTERFACE:

-Automatically wrap C header directory + library in a "module"
  -Basically need to steal or make a C preprocessor + lexer + parser
  -Most decls very similar: global constants, structs, enums, global primitives
  -Pointers cause biggest issues:
    -As variable, pointer can be used as an alias or dynamically allocated data
    -As function argument, pointer can be input or output, and can be single or array (or NULL!)
  -Struct layout in memory should be the same as C (for now at least)
  -For C functions that take C strings, use Onyx strings instead

LANGUAGE BUILT-IN MODULES (all must be fully cross-platform - "just work" with a clean Onyx installation):
  -Term (stdin/stdout/formatting/parsing)
  -Sys (File I/O, directories, sockets)
  -Modern OpenGL, plus some nice utilties, like:
    -GLM-style math
    -OBJ model loading
    -Shader utilities
    -Mesh utilities (loading, saving, refinement, decimation)
  -Font rendering (full TrueType/Unicode support)
  -Input (keyboard, mouse, gamepad - portable across all machines)
  -UI (nice libUI interface, or something similar from scratch?)
  -OpenAL (audio)
  -zlib (compression)
  -Graphs (nice data structure, shortest path, finding cycles, reachability, etc)

