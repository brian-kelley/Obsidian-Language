---------------------
      TODO:
---------------------
FRONTEND (last core language features):
-Add function overloading

Name lookup:
  * To resolve name a.b.c, find nearest "a"
    in an enclosing scope
  * Then find b in that scope only, and so on
  * "using" decls are simpler than C++: just directly
    introduce a name from one scope into the current one
  * "using module abc" introduces all names in module abc
  * "using abc" just introduces name abc
  * The names introduced have lower lookup priority than
    names already in the scope. No errors/warnings from
    conflicting names.
  * "using a.b.subr" if "subr" is already a subroutine will
    combine the overloads of the versions of subr, IF the
    purity (func/proc) and owning struct (this type) match.
    If they don't match, works like any other name, and the
    "a.b.subr" is hidden by "subr"

Name match priority in member context:
local < composition (in order of member decl) < "using" (in order of using decl)

Move this logic inside StructType - should always be able to generate a resolved
StructMem or an error, given a single name (possibly nested, for composition) 

Same for static context, except composition doesn't apply.

-Use "SubroutineExpr" only for references to nonmember subroutines
  -No longer needs "thisObject"
-Use "StructMem" for all references to methods, member vars
  -ALWAYS includes "thisObject"

-Generalize "x as Y" to provide conversion of expression x to type Y.

-Allow implicit widening conversions from one union type to another
-Allow explicit narrowing from one union to another,
  not just from a union to a member of the union

-"using <name>;" directive
  -introduces all names in another module into the current one (if name is a module),
  or just the one name (otherwise).
  -Ambiguous usage is an error: a name that has been declared or introduced via using
    more than once into the same exact scope. Can only catch this when resolving the usage,
    not when first inserting the names.
  -Now, shadowing is allowed in all cases without warning, except for local variables/parameters.
  -Prohibiting all shadowing is just too restrictive with real-life modules and large codebases.

  -After parsing, all names are registered in their scopes.
    During scope resolution, the first step must be to resolve all "using"s, so that future name
    lookup during resolution can access those.

-extern functions:
  -Need to design memory ownership model for passing pointers
  -Need to prevent leaks, use-after-free, double free
    -Each argument can have one of several different modes:
    -RELEASE: pass ownership to callee, memory no longer accessible and not responsible for freeing.
      -For arrays, this means the value is replaced by []
    -SHARE: Onyx keeps ownership and passes a non-const view.
    -SHARE_CONST: Onyx keeps ownership and passes a const view.
    -COPY: pass a deep copy
  -Should work in interpreter!
    -libc functions are already available to the compiler
    -load other functions from dynamic library

-Metaprogramming!
  -Implement "# StatementOrDecl" pattern to execute statements
    at parse time, and create meta-declarations
  -Implement all AST nodes as types

BACKEND
-IR rewrite:
  -Remove "print" and "assert" as instructions - make them FFI calls
  -Create parallel, simplified type system like LLVM
-All optimizations should work on the IR only - it should be possible to
  completely delete the AST

-Metaprogramming:
  -Put '#' before any pseudo-statement (scoped decls and regular statements)
    -A scoped decl after # must be variable or subroutine
      (all other scoped decls must exist in both meta world and regular program)
    -Meta-variables are different kind of name than (normal scoping applies)
    -Meta-subroutines can contain $/@-statements, regular ones can't
      -they can still be represented as Subroutine, just add 'meta' bool
    -Meta-statements are run at compile time (have no presense in final C/machine code output)
  -#define <identifier> <tokens> works just like C
    -meta-procs provide function-like macros
  -Implicit conversion from string to any AST node type is parsing

  -All meta-decls are resolved immediately after parsing
  -This triggers lazy resolution of any needed decls in non-meta space
    -If these decls are located earlier in the code, everything's fine
    -Otherwise, it's an error (name doesn't exist yet)

  -Meta built-in types and functions:
    -Have capitalized names be types representing AST nodes
    e.g. StringLit, For, Type, etc.
    -Have lowercase names be functions that take a string
    and parse it into an AST node

Example:
    Type t = type("float[][]");

  -New syntax rules:
  * (anywhere):     #<stmt>: execute meta-stmt or create meta-decl
  * (in meta-stmt): $<expr>: evaluate expr, unparse and output to code stream where the meta-stmt appeared
  * Save "@" for potential later use in metaprogramming...

  //This is a fully functional "include",
  //although real compiler should have #include
  //built in so that file/line/col works with multiple files
  //also, should actually include each file once, even if #included
  //multiple times
  #proc void include(string fname)
  {
    string text = readFile(fname);
    @text;
  }

  //C++ style generics (but with code size reduction option)
  //need keyword "generic"
  //example syntax:
  generic(T)
  func int serialSize(T val)
  {
    return serialize(val).len;
  }

  //compiler could implement by fully instantiating the decl for every type,
  //or by creating a single decl that has a union that covers all uses
  //suppose program uses:
  serialSize(int)(6);
  serialSize(string)("omgwtfbbq");
  serialSize(byte[])([1, 2, 3, 4, 5]);

  //there could be represented in final code by:
  func int serialSize_int__(int val)
  func int serialSize_string__(string val)
  func int serialSize_byte_arr__(byte[] val)

  //OR as:
  //argument is implicitly converted to exact match in union,
  //and if return value is a T union then extract the real value
  func int serialSize((int | string | byte[]) val)
  {
    match v : val
    {
      case int:
        return serialize(v).len;
      case string:
        return serialize(v).len;
      case byte[]:
        return serialize(v).len;
    }
  }

-----------------------------------
   After core language compiler:
-----------------------------------
BUILT-IN MODULES (all must be fully cross-platform)
  -Term (stdin/stdout/formatting/parsing, commands)
  -Sys (File I/O, filesystem, sockets, time)
  -GL (4.1+), plus some nice utilties, like:
    -GLM-style math
    -OBJ model loading
    -Shader utilities
    -Mesh utilities (half-edge structure, loading, saving)
  -Font (Unicode support, antialiasing)
  -Input (keyboard, mouse, gamepad - must be portable)
    -Want to be able to poll keys/buttons efficiently like SDL,
      or set callbacks for button events
    -callbacks can be very simple with first-class subrs
  -UI through Nuklear
  -Native audio wrapper?
  -set(T) in global, implemented as (T : void)
  -Compression, for use with serialization: Zstd? (speed > compression)
  -Graph
    -Directed and not
    -Dijkstra's algo for single source reachability/distance
    -Kosaraju's algo for strongly connected components
    -topological sort
    -Prim's algo for MST

