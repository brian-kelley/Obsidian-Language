---------------------
      TODO:
---------------------
FRONTEND (last core language features):
-Add function overloading

-Generalize "x as Y" to provide conversion of expression x to type Y.

-Allow implicit widening conversions from one union type to another
-Allow explicit narrowing from one union to another,
  not just from a union to a member of the union

-"using <name>;" directive
  -introduces all names in another module into the current one (if name is a module),
  or just the one name (otherwise).
  -Ambiguous usage is an error: a name that has been declared or introduced via using
    more than once into the same exact scope. Can only catch this when resolving the usage,
    not when first inserting the names.
  -Now, shadowing is allowed in all cases without warning, except for local variables/parameters.
  -Prohibiting all shadowing is just too restrictive with real-life modules and large codebases.

  -After parsing, all names are registered in their scopes.
    During scope resolution, the first step must be to resolve all "using"s, so that future name
    lookup during resolution can access those.

-extern functions:
  -for libc functions, compiler calls directly
  -otherwise, load the functions from dynamic library

-Metaprogramming!
  -Implement "# StatementOrDecl" pattern to execute statements
    at parse time, and create meta-declarations
  -Implement all AST nodes as types

BACKEND
-IR rewrite:
  -Remove "print" and "assert" as instructions - make them FFI calls
  -Create parallel, simplified type system like LLVM
-All optimizations should work on the IR only - it should be possible to
  completely delete the AST

-Metaprogramming:
  -Put '#' before any pseudo-statement (scoped decls and regular statements)
    -A scoped decl after # must be variable or subroutine
      (all other scoped decls must exist in both meta world and regular program)
    -Meta-variables are different kind of name than (normal scoping applies)
    -Meta-subroutines can contain $/@-statements, regular ones can't
      -they can still be represented as Subroutine, just add 'meta' bool
    -Meta-statements are run at compile time (have no presense in final C/machine code output)
  -#define <identifier> <tokens> works just like C
    -meta-procs provide function-like macros
  -Implicit conversion from string to any AST node type is parsing

  -All meta-decls are resolved immediately after parsing
  -This triggers lazy resolution of any needed decls in non-meta space
    -If these decls are located earlier in the code, everything's fine
    -Otherwise, it's an error (name doesn't exist yet)

  -Meta built-in types and functions:
    -Have capitalized names be types representing AST nodes
    e.g. StringLit, For, Type, etc.
    -Have lowercase names be functions that take a string
    and parse it into an AST node

Example:
    Type t = type("float[][]");

  -New syntax rules:
  * (anywhere):     #<stmt>: execute meta-stmt or create meta-decl
  * (in meta-stmt): $<expr>: evaluate expr, unparse and output to code stream where the meta-stmt appeared
  * Save "@" for potential later use in metaprogramming...

  //This is a fully functional "include",
  //although real compiler should have #include
  //built in so that file/line/col works with multiple files
  //also, should actually include each file once, even if #included
  //multiple times
  #proc void include(string fname)
  {
    string text = readFile(fname);
    @text;
  }

  //C++ style generics (but with code size reduction option)
  //need keyword "generic"
  //example syntax:
  generic(T)
  func int serialSize(T val)
  {
    return serialize(val).len;
  }

  //compiler could implement by fully instantiating the decl for every type,
  //or by creating a single decl that has a union that covers all uses
  //suppose program uses:
  serialSize(int)(6);
  serialSize(string)("omgwtfbbq");
  serialSize(byte[])([1, 2, 3, 4, 5]);

  //there could be represented in final code by:
  func int serialSize_int__(int val)
  func int serialSize_string__(string val)
  func int serialSize_byte_arr__(byte[] val)

  //OR as:
  //argument is implicitly converted to exact match in union,
  //and if return value is a T union then extract the real value
  func int serialSize((int | string | byte[]) val)
  {
    match v : val
    {
      case int:
        return serialize(v).len;
      case string:
        return serialize(v).len;
      case byte[]:
        return serialize(v).len;
    }
  }

-----------------------------------
   After core language compiler:
-----------------------------------
BUILT-IN MODULES (all must be fully cross-platform)
  -Term (stdin/stdout/formatting/parsing, commands)
  -Sys (File I/O, filesystem, sockets, time)
  -GL (4.1+), plus some nice utilties, like:
    -GLM-style math
    -OBJ model loading
    -Shader utilities
    -Mesh utilities (half-edge structure, loading, saving)
  -Font (Unicode support, antialiasing)
  -Input (keyboard, mouse, gamepad - portable across all machines)
    -Want to be able to poll keys/buttons efficiently like SDL,
      or set callbacks for specific events
    -callbacks can be very simple with first-class subrs
  -UI through Nuklear
  -Native audio wrapper?
  -set(T) in global, implemented as (T : void)
  -Compression, for use with serialization: Zstd? (speed > compression)
  -Graph
    -Directed and not
    -Dijkstra's algo for single source reachability/distance
    -Kosaraju's algo for strongly connected components
    -topological sort
    -Prim's algo for MST

