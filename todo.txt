---------------------
      TODO:
---------------------
-Make Expressions know if they have side effects or not
  -Cannot attempt constant folding on these
-During constant propagation, use short-circuit evaluation any time
  a || or && is encountered

-IR changes
  -Replace CallIR with EvalIR, which
    evaluates an expression (with side effects) and discards the result
    -Never make an EvalIR without side effects
  -Expand all expressions into temporaries
    -Each IR statement has at most 1 call,
     easy to determine if it has side effects
    -Record the orignal expressions that are stored in
     each temporary
      -Every computation benefitting from CSE is assigned
        to a temporary
    -Do a CSE pass:
      -If any expression is the definition of some temporary,
        replace the expression with reference to the temporary
      -Do forward dataflow with the precomputed sets of temporaries/exprs
      -Implement a hash function for Expression*
        -Note: BinaryAriths with commutative operator and switched arguments
          should compare equal
        -Use unordered_map<Expression*, Variable*, ExprHash, ExprEqual> to
          efficiently look up available expressions
    -Do a copy propagation pass:
      -If the last definition of variable X is just Y,
        then replace all reads from X with Y
  -Then run liveness analysis.
    -Delete all assignments to dead variables
      -If the definitions have side effects, replace AssignIR with EvalIR
      -If variables are never alive, remove them from their Scope

-Make sure short-circuit evaluation is implemented in C backend

-DON'T bother combining binary operations with associative operators -
  the C compiler or LLVM will always be able to handle that

-Add include keyword
  -read source file (if that fails, give informative message)
  -lex and insert tokens at current position (can use a secondary token stream here)
  -remember source locations where each included file was included
  -include should be idempotent (doing it again with same file is no-op)
    -don't even read the file if the path is already in table
    -note: canonicalize paths
-Implement external functions in backend
-Implement generic keyword (see below)
  -generic is just another kind of ScopedDecl (and Name)
-Add punctuation for meta: @ $ @> $>
-In parser, add hook for meta statements (see a # means parse & exec stmt/decl)

-Metaprogramming:
  -Put '#' before any pseudo-statement (scoped decls and regular statements)
    -A scoped decl after # must be variable or subroutine
      (all other scoped decls must exist in both meta world and regular program)
    -Meta-variables are different kind of name than (normal scoping applies)
    -Meta-subroutines can contain $/@-statements, regular ones can't
      -they can still be represented as Subroutine, just add 'meta' bool
    -Meta-statements are run at compile time (have no presense in final C/machine code output)
  -#define <identifier> <tokens> works just like C
    -meta-procs provide function-like macros
  -Implicit conversion from string to any AST node type is parsing

  -All meta-decls are resolved immediately after parsing
  -This triggers lazy resolution of any needed decls in non-meta space
    -If these decls are located earlier in the code, everything's fine
    -Otherwise, it's an error (name doesn't exist yet)

  -New syntax rules:
  * (any):                #<stmt>: execute meta-stmt or create meta-decl
  * (stmt in meta-subr):  @<expr>: evaluate expr at compile time, expr must be string, and output lex(expr) to code stream
  * (stmt in meta-subr):  $<expr>: evaluate expr at compile time, and output it to code
  * $> <expr> and @> <expr> append tokens to end of code, not current position
      * for values, create equivalent literal (ALL values can be represented as primitive or compound literals)
      * for AST elements, unparse back to tokens

  //Example: do10(b) generates a loop that runs b 10 times
  #proc void do10(Block b)
  {
    @"for i : 0,10";
    $b;
  }

  //This is a fully functional "include",
  //although real compiler should have #include
  //built in so that file/line/col works with multiple files
  //also, should actually include each file once, even if #included
  //multiple times
  #proc void include(string fname)
  {
    string text = readFile(fname);
    @text;
  }

  //C++ style generics (but with code size reduction option)
  //need keyword "generic"
  //example syntax:
  generic(T)
  func int serialSize(T val)
  {
    return serialize(val).len;
  }

  //compiler could implement by fully instantiating the decl for every type,
  //or by creating a single decl that has a union that covers all uses
  //suppose program uses:
  serialSize(int)(6);
  serialSize(string)("omgwtfbbq");
  serialSize(byte[])([1, 2, 3, 4, 5]);

  //there could be represented in final code by:
  func int serialSize_int__(int val)
  func int serialSize_string__(string val)
  func int serialSize_byte_arr__(byte[] val)

  //OR as:
  //argument is implicitly converted to exact match in union,
  //and if return value is a T union then extract the real value
  func int serialSize((int | string | byte[]) val)
  {
    match v : val
    {
      case int:
        return serialize(v).len;
      case string:
        return serialize(v).len;
      case byte[]:
        return serialize(v).len;
    }
  }

-----------------------------------
   After core language compiler:
-----------------------------------
BUILT-IN MODULES (all must be fully cross-platform)
  -Term (stdin/stdout/formatting/parsing, commands)
  -Sys (File I/O, filesystem, sockets, time)
  -GL (4.1+), plus some nice utilties, like:
    -GLM-style math
    -OBJ model loading
    -Shader utilities
    -Mesh utilities (half-edge structure, loading, saving)
  -Font (Unicode support, antialiasing)
  -Input (keyboard, mouse, gamepad - portable across all machines)
    -Want to be able to poll keys/buttons efficiently like SDL,
      or set callbacks for specific events
    -callbacks can be very simple with first-class subrs
  -UI through Nuklear
  -Native audio wrapper?
  -set(T) in global, implemented as (T : void)
  -Compression, for use with serialization: Zstd? (speed > compression)
  -Graph
    -Directed and not
    -Dijkstra's algo for single source reachability/distance
    -Kosaraju's algo for strongly connected components
    -topological sort
    -Prim's algo for MST

