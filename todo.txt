---------------------
      TODO:
---------------------
-Allow subroutine overloading
-This is so that calling with union argument(s) will dynamic dispatch to the correct version for contents IF version taking the exact union directly doesn't exist
  -To find matching subr, take first found where arguments exactly match,
  then where arguments are convertible (lex order breaks ties)

-Parse tree/AST merge refactoring
  -Parsing a nonterminal should do all possible semantic checking given incomplete context
  -Add virtual void check() to nonterminal, which does the full context sensitive semantic checking
  -metaStatement() will call check() during parsing, since full semantics of statement must be known immediately
  -after parsing, regular parse tree will be traversed in order and check() will be called on each node

-Metaprogramming:
  -Put '#' before any pseudo-statement (scoped decls and regular statements)
    -A scoped decl after # must be variable or subroutine
    -Meta-variables are different kind of name than (normal scoping applies)
    -Meta-subroutines are allowed to contain emit(), regular ones aren't
      -they can still be represented as Subroutine, just add 'meta' bool
    -Meta-statements are run at compile time and not included anywhere in generated code
    -the '#' makes them trivial to parse: any time a '#' token is seen, parse and run a statement
    -#emit(nonterminal); can also go anywhere

  //Example: do10(b) generates a loop that runs b 10 times
  #proc void do10(Block b)
  {
    emit("for i : 0,10 ");
    emit(b);
  }

  //this call will be 
  #do10({print("Hello world\n");})

  -Parser works through a single, linear token stream
  -If at any point the parser looks ahead to '#', parse a meta-statement there
  -In this context, statements can be declarations or actions

-Front end: text stream -> token stream -> parse tree
-Middle end: parse tree -> fully typed and semantically checked intermediate representation
-Meta-interpreter: IR -> more program source and parse tree nodes to be inserted
  -emitted parse nodes will be written out as text
-Run different (pre-backend) compiler stages as a pipeline instead of distinct steps as is done now
  -Allow for inserting program text at the start of stream without actually modifying original code string (performance)
  -this means that meta-stuff requires all types/subroutines to be declared before use (no good way around this?)
    -can't just leave it as deferred, because emitting code can arbitrarily affect compilation later in the source
    -if name lookup fails in the course of interpreting, immediate error

-Interoperation with arbitrary c libraries: function description is a C string that is inlined at every call site in Onyx source
  -this string provides the body of a C function
-C variadic funcs are not supported

-Backend: emitting control flow statements (break, continue, return) should free locals in scopes that close
  -normally, closing a block will call popScope() exactly once
-break from loop needs to pop from innermost block up to and including the loop block
  -break from switch only pops blocks that are inside the switch
  -continue in loop pops innermost block up to but not including the loop block
  -return pops from innermost block up to and including the innermost subroutine
  -this special control flow instructions don't actually call popScope() at all, because technically those scopes
  are still open (even if the real block pop code is unreachable)

-----------------------------------
   After core language compiler:
-----------------------------------
BUILT-IN MODULES (all must be fully cross-platform)
  -Term (stdin/stdout/formatting/parsing, commands)
  -Sys (File I/O, filesystem, sockets, time)
  -GL (4.1+), plus some nice utilties, like:
    -GLM-style math
    -OBJ model loading
    -Shader utilities
    -Mesh utilities (half-edge structure, loading, saving)
  -Font (Unicode support, antialiasing)
  -Input (keyboard, mouse, gamepad - portable across all machines)
    -Want to be able to poll efficiently like SDL,
      or set callbacks for specific events
  -UI (something like libUI, but from scratch)
  -Native audio wrapper
  -set(T) in global, implemented as (T : void)
  -Compression, for use with serialization: Zstandard?
  -Graph
    -Directed and not
    -Dijkstra's algo for single source reachability/distance
    -Kosaraju's algo for strongly connected components
    -topological sort
    -Prim's algo for minimum spanning tree
  -Codec: ffmpeg wrappers

