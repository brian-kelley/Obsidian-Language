#include "C_Backend.hpp"
#include <utility>

using namespace TypeSystem;
using std::pair;

map<Type*, string> types;
map<Type*, bool> typesImplemented;
map<Subroutine*, string> subrs;
map<Variable*, string> vars;

//The sets of types where util functions have been implemented
set<Type*> initImpl;
set<Type*> copyImpl;
set<Type*> allocImpl;
set<Type*> deallocImpl;
set<Type*> printImpl;
set<Type*> hashImpl;
set<pair<Type*, Type*>> convertImpl;
set<Type*> equalsImpl;
set<Type*> lessImpl;
set<ArrayType*> concatImpl;
set<ArrayType*> prependImpl;
set<ArrayType*> appendImpl;
set<ArrayType*> accessImpl;
set<ArrayType*> assignImpl;

map<Type*, bool> needsDealloc;   //whether each type needs a non-trivial deallocator
size_t identCount;
ofstream c;
//different stringstreams to build the C file (in this order)
Oss typeDecls;      //all typedefs (including forward-declarations as necessary)
Oss varDecls;       //all global/static variables
Oss utilFuncDecls;  //util functions are print, array creation, deep copy, etc
Oss utilFuncDefs;
Oss funcDecls;      //the actual subroutines in the onyx program
Oss funcDefs;

namespace Context
{
  map<Switch*, string> switchBreakLabels;
  map<For*, string> forBreakLabels;
}

//The C type to use for array sizes/indices
const char* size_type = "uint32_t";

namespace C
{
  void generate(string outputStem, bool keep)
  {
    cout << "Starting C backend.\n";
    string cName = outputStem + ".c";
    string exeName = outputStem + ".exe";
    typeDecls = Oss();
    varDecls = Oss();
    utilFuncDecls = Oss();
    utilFuncDefs = Oss();
    funcDecls = Oss();
    funcDefs = Oss();
    generateSectionHeader(utilFuncDecls, "Internal functions");
    cout << "  > Generating type declarations\n";
    generateSectionHeader(typeDecls, "Type Decls");
    genTypeDecls();
    cout << "  > Generating global variables\n";
    generateSectionHeader(varDecls, "Global Variables");
    genGlobals();
    cout << "  > Generating Onyx subroutines\n";
    generateSectionHeader(funcDecls, "Subroutine declarations");
    generateSectionHeader(funcDefs, "Subroutine definitions");
    genSubroutines();
    c = ofstream(cName);
    c << "//--- " << outputStem << ".c, generated by the Onyx Compiler ---//\n\n";
    //genCommon writes directly to the c stream
    genCommon();
    implHashTable();
    //write types, vars, func decls, func defs in the ostringstreams
    c.write(typeDecls.str().c_str(), typeDecls.tellp());
    c << "\n";
    c.write(varDecls.str().c_str(), varDecls.tellp());
    c << "\n";
    c.write(utilFuncDecls.str().c_str(), utilFuncDecls.tellp());
    c << "\n";
    c.write(utilFuncDefs.str().c_str(), utilFuncDefs.tellp());
    c.write(funcDecls.str().c_str(), funcDecls.tellp());
    c << "\n";
    c.write(funcDefs.str().c_str(), funcDefs.tellp());
    c << '\n';
    cout << "  > Done, wrote " << c.tellp() << " bytes of C source code\n";
    c.close();
    //wait for cc to terminate
    bool smallBin = false;
    bool compileSuccess = false;
    //Common flags for C compiler
    string cflags = "-Wall -Wextra -Werror --std=c99 -ffast-math -fassociative-math -o " + exeName + ' ' + cName;
    if(smallBin)
    {
      compileSuccess = runCommand("gcc -Os " + cflags + " &> cc.out");
      //shrink binary some more (no need for symbol names)
      runCommand(string("gstrip --strip-all ") + exeName, true);
    }
    else
    {
      compileSuccess = runCommand("gcc -g " + cflags + " &> cc.out");
    }
    if(!keep)
    {
      remove(cName.c_str());
    }
    if(!compileSuccess)
    {
      ERR_MSG("C compiler encountered error.");
    }
  }

  void genCommon()
  {
    c <<
      "#include \"stdio.h\"\n"
      "#include \"stdlib.h\"\n"
      "#include \"math.h\"\n"
      "#include \"string.h\"\n"
      "#include \"stdint.h\"\n"
      "#include \"stdbool.h\"\n\n"
      "char* strdup_(const char* str)\n"
      "{\n"
      "char* temp = malloc(1 + strlen(str));\n"
      "strcpy(temp, str);\n"
      "return temp;\n"
      "}\n\n"
      "void panic_(const char* why_)\n"
      "{\n"
      "fprintf(stderr, \"%s\\n\", why_);\n"
      "exit(1);\n"
      "}\n\n";
  }

  void implHashTable()
  {
    //each hash table entry contains key ptr, value ptr and hash
    utilFuncDecls <<
      "\ntypedef struct\n"
      "{\n"
      "void** keys;\n"
      "void** values;\n"
      "uint64_t* hashes;\n"
      "int size;\n"
      "int cap;\n"
      "} Bucket;\n\n"
      "typedef struct\n"
      "{\n"
      "uint64_t (*hashFn)(void* data);\n"
      "bool (*compareFn)(void* lhs, void* rhs);\n"
      "Bucket* buckets;\n"
      "int size;\n"         //size = number of key-value pairs
      "int numBuckets;\n"   //log2(actual number of buckets)
      "} HashTable;\n\n"
      "void hashInsert(HashTable* table, void* key, void* data);\n"
      "void* hashFind(HashTable* table, void* key);\n"
      "void hashRemove(HashTable* table, void* key);\n";
    utilFuncDefs <<
      "void bucketInsert(Bucket* bucket, void* key, void* data, uint64_t hash)\n{\n"
      "if(bucket->size == bucket->cap)\n"
      "{\n"
      "int newCap = (bucket->cap == 0) ? 1 : bucket->cap * 2;\n"
      "bucket->keys = realloc(bucket->keys, newCap * sizeof(void*));\n"
      "bucket->values = realloc(bucket->values, newCap * sizeof(void*));\n"
      "bucket->cap = newCap;\n"
      "}\n"
      "bucket->hash = hash;\n"
      "bucket->keys[bucket->size] = key;\n"
      "bucket->values[bucket->size] = value;\n"
      "bucket->hashes[bucket->size] = hash;\n"
      "bucket->size++;\n"
      "}\n\n"
      "void bucketRemove(Bucket* bucket, void* key, bool (*compareFn)(void* lhs, void* rhs))\n"
      "{\n"
      "for(int i = 0; i < bucket->size; i++)\n"
      "{\n"
      "if(compareFn(bucket->keys[i], key))\n"
      "{\n"
      "//found it, shift all the arrays down 1 element\n"
      "memmove(bucket->keys + i, bucket->keys + i + 1, sizeof(void*) * (bucket->size - i - 1));\n"
      "memmove(bucket->values + i, bucket->values + i + 1, sizeof(void*) * (bucket->size - i - 1));\n"
      "memmove(bucket->hashes + i, bucket->hashes + i + 1, sizeof(uint64_t) * (bucket->size - i - 1));\n"
      "bucket->size--;\n"
      "if(bucket->size == 0)\n"
      "{\n"
      "free(bucket->keys);\n"
      "free(bucket->values);\n"
      "free(bucket->hashes);\n"
      "bucket->cap = 0;\n"
      "}\n"
      "break;\n"
      "}\n"
      "}\n"
      "}\n\n"
      "void* bucketFind(Bucket* bucket, void* key, bool (*compareFn)(void* lhs, void* rhs))\n"
      "{\n"
      "for(int i = 0; i < bucket->size; i++)\n"
      "{\n"
      "if(compareFn(bucket->keys[i], key))\n"
      "return bucket->values[i];\n"
      "}\n"
      "return NULL;\n"
      "}\n\n"
      "void hashInsert(HashTable* table, void* key, void* data)\n{\n"
      "//resize table if necessary\n"
      "if(table->size == table->cap)\n"
      "{\n"
      "int nb = table->numBuckets + 1;\n"
      "Bucket* newBuckets = calloc(1 << nb, sizeof(Bucket));\n"
      "for(int i = 0; i < table->numBuckets; i++)\n"
      "{\n"
      "Bucket* oldBucket = table->buckets[i];\n"
      "for(int j = 0; j < oldBucket->size; j++)\n"
      "{\n"
      "Bucket* newBucket = newBuckets[oldBucket->hashes[j] % nb];\n"
      "bucketInsert(newBucket, oldBucket->keys[j], oldBucket->values[j], oldBucket->hashes[j]);\n"
      "}\n"
      "//free the bucket and its contents\n"
      "free(oldBucket->keys);\n"
      "free(oldBucket->values);\n"
      "free(oldBucket->hashes);\n"
      "}\n"
      "free(table->buckets);\n"
      "table->buckets = newBuckets;\n"
      "table->nb++;\n"
      "}\n"
      "uint64_t h = (table->hashFn)(key);\n"
      "bucketInsert(table->buckets[h & ((1 << table->numBuckets) - 1)], key, value, h);\n"
      "}\n\n"
      "void* hashFind(HashTable* table, void* key)\n{\n"
      "return bucketFind(table->buckets[(table->hashFn)(key) & ((1 << table->numBuckets) - 1)], key, table->compareFn);\n"
      "}\n\n"
      "void hashRemove(HashTable* table, void* key)\n{\n"
      "bucketRemove(table->buckets[(table->hashFn)(key) & ((1 << table->numBuckets) - 1)], key, table->compareFn);\n"
      "}\n\n";
  }

  void genTypeDecls()
  {
    types[TypeSystem::primNames["void"]] = "void";
    types[TypeSystem::primNames["Error"]] = "void";
    types[TypeSystem::primNames["bool"]] = "bool";
    types[TypeSystem::primNames["char"]] = "char";
    types[TypeSystem::primNames["byte"]] = "int8_t";
    types[TypeSystem::primNames["ubyte"]] = "uint8_t";
    types[TypeSystem::primNames["short"]] = "int16_t";
    types[TypeSystem::primNames["ushort"]] = "uint16_t";
    types[TypeSystem::primNames["int"]] = "int32_t";
    types[TypeSystem::primNames["uint"]] = "uint32_t";
    types[TypeSystem::primNames["long"]] = "int64_t";
    types[TypeSystem::primNames["ulong"]] = "uint64_t";
    types[TypeSystem::primNames["float"]] = "float";
    types[TypeSystem::primNames["double"]] = "double";
    for(auto prim : TypeSystem::primitives)
    {
      typesImplemented[prim] = true;
    }
    //like primitives, enums can be fully implemented immediately
    for(auto et : enums)
    {
      typesImplemented[et] = true;
      types[et] = "int64_t";
    }
    //need to assign names to and forward declare structs
    //for all non-primitive types
    auto forwardDeclare = [&] (Type* t) -> void
    {
      typesImplemented[t] = false;
      types[t] = getIdentifier();
      typeDecls << "struct _" << types[t] << ";\n";
      typeDecls << "typedef struct _" << types[t] << ' ' << types[t] << "; //" << t->getName() << '\n';
    };
    for(auto t : structs)
    {
      forwardDeclare(t);
    }
    for(auto t : arrays)
    {
      forwardDeclare(t);
    }
    for(auto t : unions)
    {
      forwardDeclare(t);
    }
    for(auto t : maps)
    {
      forwardDeclare(t);
    }
    for(auto t : tuples)
    {
      forwardDeclare(t);
    }
    typeDecls << '\n';
    //implement all callable types
    for(auto t : callables)
    {
      CallableType* ct = (CallableType*) t;
      string ident = getIdentifier();
      types[t] = ident;
      typesImplemented[t] = true;
      typeDecls << "typedef " << types[ct->returnType] << "(*" << ident << ")(";
      for(size_t i = 0; i < ct->argTypes.size(); i++)
      {
        if(i != 0)
          typeDecls << ", ";
        typeDecls << types[ct->argTypes[i]] << '*';
      }
      typeDecls << "); //" << t->getName() << "\n";
    }
    typeDecls << '\n';
    //implement all compound types
    for(auto at : arrays)
    {
      typeDecls << "struct " << types[at] << " //" << at->getName() << "\n{\n";
      typeDecls << types[at->subtype] << "* data;\n";
      typeDecls << "int dim;\n";
      typeDecls << "};\n\n";
    }
    for(auto tt : tuples)
    {
      typeDecls << "struct " << types[tt] << " //" << tt->getName() << "\n{\n";
      for(size_t i = 0; i < tt->members.size(); i++)
      {
        typeDecls << types[tt->members[i]] << "* mem" << i << ";\n";
      }
      typeDecls << "};\n\n";
    }
    for(auto ut : unions)
    {
      typeDecls << "struct " << types[ut] << " //" << ut->getName() << "\n{\n";
      typeDecls << "void* data;\n";
      typeDecls << "int tag;\n";
      typeDecls << "};\n\n";
    }
    for(auto st : structs)
    {
      typeDecls << "struct " << types[st] << " //" << st->getName() << "\n{\n";
      for(size_t i = 0; i < st->members.size(); i++)
      {
        typeDecls << types[st->members[i]->type] << "* mem" << i << ";\n";
      }
      typeDecls << "};\n\n";
    }
    for(auto mt : maps)
    {
      typeDecls << "typedef HashTable " << types[mt] << "; //" << mt->getName() << '\n';
    }
  }

  void genGlobals()
  {
    int numGlobals = 0;
    walkScopeTree([&] (Scope* s) -> void
      {
        if(dynamic_cast<BlockScope*>(s) || dynamic_cast<SubroutineScope*>(s))
        {
          //don't do local variables
          return;
        }
        for(auto n : s->names)
        {
          if(n.second.kind != Name::VARIABLE)
          {
            continue;
          }
          Variable* v = (Variable*) n.second.item;
          if(v->isMember)
          {
            return;
          }
          string ident = getIdentifier();
          vars[v] = ident;
          varDecls << types[v->type] << " " << ident << "; //" << v->name << '\n';
          numGlobals = 0;
        }
      });
    if(numGlobals)
    {
      varDecls << '\n';
    }
  }

  void genSubroutines()
  {
    walkScopeTree([&] (Scope* s) -> void
      {
        for(auto& n : s->names)
        {
          if(n.second.kind != Name::SUBROUTINE || n.first == "main")
          {
            continue;
          }
          auto sub = (Subroutine*) n.second.item;
          string name = getIdentifier();
          subrs[sub] = name;
          funcDecls << types[sub->type->returnType] << "* " << name << '(';
          int totalArgs = 0;
          if(sub->type->ownerStruct)
          {
            funcDecls << types[sub->type->ownerStruct] << "* this_";
            totalArgs++;
          }
          for(size_t i = 0; i < sub->args.size(); i++)
          {
            auto arg = sub->args[i];
            if(totalArgs > 0)
            {
              funcDecls << ", ";
            }
            totalArgs++;
            string argName = getIdentifier();
            vars[arg] = argName;
            funcDecls << types[arg->type] << ' ' << argName;
          }
          funcDecls << ");\n";
        }
      });
    walkScopeTree([&] (Scope* s) -> void
      {
        for(auto& n : s->names)
        {
          if(n.second.kind != Name::SUBROUTINE || n.first == "main")
          {
            continue;
          }
          auto sub = (Subroutine*) n.second.item;
          funcDefs << types[sub->type->returnType] << ' ' << subrs[sub] << '(';
          int totalArgs = 0;
          if(sub->type->ownerStruct)
          {
            funcDefs << types[sub->type->ownerStruct] << "* this_";
            totalArgs++;
          }
          for(size_t i = 0; i < sub->args.size(); i++)
          {
            auto arg = sub->args[i];
            if(totalArgs > 0)
            {
              funcDefs << ", ";
            }
            totalArgs++;
            string argName = getIdentifier();
            vars[arg] = argName;
            funcDefs << types[arg->type] << ' ' << argName;
          }
          funcDefs << ")\n";
          generateBlock(funcDefs, sub->body);
          funcDefs << '\n';
        }
      });
    genMain((Subroutine*) global->names["main"].item);
  }

  void genMain(Subroutine* m)
  {
    funcDefs << "int main(";
    if(m->args.size() == 1)
    {
      //single argument: array of strings
      //in C this means (int, const char**)
      funcDefs << "int argc_, const char** argv_)\n{\n";
      //manually allocate the string[] and copy in the args
      //(don't include the first argument)
      Type* stringType = dynamic_cast<ArrayType*>(m->args[0]->type)->subtype;
      Variable* arg = m->args[0];
      vars[arg] = getIdentifier();
      funcDefs << types[arg->type] << "* " << vars[arg] << " = ";
      funcDefs << getAllocFunc((ArrayType*) arg->type) << "(argc_ - 1, 0);\n";
      funcDefs << "for(int i = 0; i < argc - 1; i_++)\n{\n";
      funcDefs << vars[arg] << "->data[i] = calloc(1, sizeof(" << types[stringType] << "));\n";
      funcDefs << vars[arg] << "->data[i]->data = malloc(strlen(argv[i] + 1));\n";
      funcDefs << "strcpy(" << vars[arg] << "->data[i]->data, argv[i]);\n";
      funcDefs << vars[arg] << "->data[i]->dim = strlen(argv[i]);\n";
      funcDefs << "}\n";
    }
    else
    {
      funcDefs << ")\n{\n";
    }
    //generate local variables
    generateLocalVariables(funcDefs, m->body->scope);
    //generate all statements like normal (one at a time)
    for(auto stmt : m->body->stmts)
    {
      generateStatement(funcDefs, m->body, stmt);
    }
    //if main was declared void, add "return 0" to avoid warning
    //(because C return type is always int)
    if(m->type->returnType == primitives[Parser::TypeNT::VOID])
    {
      funcDefs << "return 0;\n";
    }
    funcDefs << "}\n";
  }

  void generateExpression(ostream& c, Expression* expr)
  {
    //Expressions in C mostly depend on the subclass of expr
    if(UnaryArith* unary = dynamic_cast<UnaryArith*>(expr))
    {
      c << '(';
      c << operatorTable[unary->op];
      c << "(*";
      generateExpression(c, unary->expr);
      c << "))";
    }
    else if(BinaryArith* binary = dynamic_cast<BinaryArith*>(expr))
    {
      //fully parenthesize binary exprs so that it works
      //in case onyx ends up with different operator precedence than C
      //arithmetic operators are trivial (except array concatenation/prepend/append)
      if(binary->op == CMPEQ)
      {
        c << getEqualsFunc(binary->lhs->type) << '(';
        generateExpression(c, binary->lhs);
        c << ", ";
        generateExpression(c, binary->rhs);
        c << ')';
      }
      else if(binary->op == CMPNEQ)
      {
        c << "(!" << getEqualsFunc(binary->lhs->type) << '(';
        generateExpression(c, binary->lhs);
        c << ", ";
        generateExpression(c, binary->rhs);
        c << "))";
      }
      else if(binary->op == CMPL)
      {
        c << getLessFunc(binary->lhs->type) << '(';
        generateExpression(c, binary->lhs);
        c << ", ";
        generateExpression(c, binary->rhs);
        c << ')';
      }
      else if(binary->op == CMPLE)
      {
        c << "(!" << getLessFunc(binary->lhs->type) << '(';
        generateExpression(c, binary->rhs);
        c << ", ";
        generateExpression(c, binary->lhs);
        c << "))";
      }
      else if(binary->op == CMPG)
      {
        c << getLessFunc(binary->lhs->type) << '(';
        generateExpression(c, binary->rhs);
        c << ", ";
        generateExpression(c, binary->lhs);
        c << ')';
      }
      else if(binary->op == CMPGE)
      {
        c << "(!" << getLessFunc(binary->lhs->type) << '(';
        generateExpression(c, binary->lhs);
        c << ", ";
        generateExpression(c, binary->rhs);
        c << "))";
      }
      else if(binary->op == PLUS &&
          binary->lhs->type->isArray() && binary->rhs->type->isArray())
      {
        //array concat
        c << getConcatFunc((ArrayType*) binary->lhs->type) << '(';
        generateExpression(c, binary->lhs);
        c << ", ";
        generateExpression(c, binary->rhs);
        c << ')';
      }
      else if(binary->op == PLUS && binary->lhs->type->isArray())
      {
        //array append
        c << getAppendFunc((ArrayType*) binary->lhs->type) << '(';
        generateExpression(c, binary->lhs);
        c << ", ";
        generateExpression(c, binary->rhs);
        c << ')';
      }
      else if(binary->op == PLUS && binary->rhs->type->isArray())
      {
        //array prepend
        c << getPrependFunc((ArrayType*) binary->rhs->type) << '(';
        generateExpression(c, binary->lhs);
        c << ", ";
        generateExpression(c, binary->rhs);
        c << ')';
      }
      else
      {
        c << "(*";
        generateExpression(c, binary->lhs);
        c << ')';
        c << operatorTable[binary->op];
        c << "(*";
        generateExpression(c, binary->rhs);
        c << ')';
      }
    }
    else if(IntLiteral* intLit = dynamic_cast<IntLiteral*>(expr))
    {
      //allocate with the proper size and then assign
      c << "({" << types[intLit->type] << "* ptr = malloc(sizeof(" << types[intLit->type] << "); *ptr = " << intLit->value;
      if(intLit->value > INT_MAX)
      {
        c << "LL";
      }
      c << "; ptr;})";
    }
    else if(FloatLiteral* floatLit = dynamic_cast<FloatLiteral*>(expr))
    {
      //all float lits have type double
      c << "({double* ptr = malloc(sizeof(double)); *ptr = ";
      c << floatLit->value << "; ptr;})";
    }
    else if(StringLiteral* stringLit = dynamic_cast<StringLiteral*>(expr))
    {
      //generate a char[] struct using C struct literal
      auto len = stringLit->value.length();
      string& t = types[TypeSystem::getArrayType(primNames["char"], 1)];
      c << "({" << t << "* ptr = malloc(sizeof(" << t << ")); ";
      c << "ptr->data = strdup(\"";
      //generate the characters of the string literal one at a time, using escapes as needed
      for(char ch : stringLit->value)
      {
        c << generateChar(ch);
      }
      c << "\"); ptr->dim = " << len << "; ptr;})";
    }
    else if(CharLiteral* charLit = dynamic_cast<CharLiteral*>(expr))
    {
      c << "({char* ptr = malloc(1); ";
      c << "*ptr = '";
      c << generateChar(charLit->value);
      c << "'; ptr;})";
    }
    else if(BoolLiteral* boolLit = dynamic_cast<BoolLiteral*>(expr))
    {
      c << "({bool* ptr = malloc(sizeof(bool)); *bool = ";
      c << (boolLit->value ? "true" : "false");
      c << "; ptr;})";
    }
    else if(Indexed* indexed = dynamic_cast<Indexed*>(expr))
    {
      //Indexed expression must be either a tuple or array
      auto indexedType = indexed->group->type;
      if(ArrayType* at = dynamic_cast<ArrayType*>(indexedType))
      {
        c << getAccessFunc(at) << '(';
        generateExpression(c, indexed->group);
        c << ", ";
        generateExpression(c, indexed->index);
        c << ')';
      }
      else if(dynamic_cast<TupleType*>(indexedType))
      {
        //tuple: simply reference the requested member
        c << '(';
        generateExpression(c, indexed->group);
        //index must be an IntLiteral (has already been checked)
        c << ")->mem" << dynamic_cast<IntLiteral*>(indexed)->value << ')';
      }
    }
    else if(CallExpr* call = dynamic_cast<CallExpr*>(expr))
    {
      if(auto subrExpr = dynamic_cast<SubroutineExpr*>(call->callable))
      {
        c << subrs[subrExpr->subr] << "(";
        if(subrExpr->thisObject)
        {
          generateExpression(c, subrExpr->thisObject);
        }
        for(size_t i = 0; i < call->args.size(); i++)
        {
          if(i > 0 || subrExpr->thisObject)
          {
            c << ", ";
          }
          generateExpression(c, call->args[i]);
        }
        c << ')';
      }
      else
      {
        //subroutine is a first-class function (any expression)
        //is a method call iff callable is a StructMem
        if(auto sm = dynamic_cast<StructMem*>(call->callable))
        {
          //need to evaluate sm->base exactly once
          //this is because the value of base is used
          //once to get the function ptr and again as this
          string baseTemp = getIdentifier();
          c << "({" << types[sm->base->type] << "* " << baseTemp << " = ";
          generateExpression(c, sm->base);
          c << "; ";
          //base is now available so evaluate the callable
          c << '(' << baseTemp << "->mem";
          StructType* st = (StructType*) sm->base->type;
          for(size_t i = 0; i < st->members.size(); i++)
          {
            if(st->members[i] == sm->member)
            {
              c << i;
              break;
            }
          }
          c << ")(" << baseTemp;
          for(auto arg : call->args)
          {
            c << ", ";
            generateExpression(c, arg);
          }
          c << ");})";
        }
        else
        {
          //just evaluate the expression which
          //is a function ptr, and do the non-method call
          generateExpression(c, call->callable);
          c << '(';
          for(size_t i = 0; i < call->args.size(); i++)
          {
            if(i > 0 || sm->base->assignable())
            {
              c << ", ";
            }
            generateExpression(c, call->args[i]);
          }
          c << ')';
        }
      }
    }
    else if(VarExpr* var = dynamic_cast<VarExpr*>(expr))
    {
      c << vars[var->var];
    }
    else if(NewArray* na = dynamic_cast<NewArray*>(expr))
    {
      //call the new array function with na's dimensions
      c << getAllocFunc((ArrayType*) na->type) << '(';
      for(size_t i = 0; i < na->dims.size(); i++)
      {
        generateExpression(c, na->dims[i]);
        if(i != na->dims.size() - 1)
          c << ", ";
      }
      c << ')';
    }
    else if(auto se = dynamic_cast<SubroutineExpr*>(expr))
    {
      c << subrs[se->subr];
    }
    else if(StructMem* sm = dynamic_cast<StructMem*>(expr))
    {
      if(dynamic_cast<ThisExpr*>(sm->base->type))
      {
        c << "this";
      }
      else
      {
        generateExpression(c, sm->base);
      }
      //find index of sm->member
      int memIndex = -1;
      StructType* st = (StructType*) sm->base->type;
      for(size_t i = 0; i < st->members.size(); i++)
      {
        if(sm->member == st->members[i])
        {
          memIndex = i;
          break;
        }
      }
      c << "->mem" << memIndex;
    }
    else if(auto subExpr = dynamic_cast<SubroutineExpr*>(expr))
    {
      c << subrs[subExpr->subr];
    }
    else if(auto converted = dynamic_cast<Converted*>(expr))
    {
      c << getConvertFunc(converted->type, converted->value->type) << "(";
      generateExpression(c, converted->value);
      c << ')';
    }
    else if(auto ee = dynamic_cast<EnumExpr*>(expr))
    {
      c << '(' << ee->value << ')';
    }
    else if(auto cl = dynamic_cast<CompoundLiteral*>(expr))
    {
      //create a tuple representing compound lit,
      //and assign each member individually in a statement expression
      string tupName = getIdentifier();
      c << "({" << types[cl->type] << ' ' << tupName << ";\n";
      for(size_t i = 0; i < cl->members.size(); i++)
      {
        c << tupName << "->mem" << i << " = ";
        generateExpression(c, cl->members[i]);
        c << ";\n";
      }
      c << tupName << ";})";
    }
    else if(dynamic_cast<ErrorVal*>(expr))
    {
      INTERNAL_ERROR;
    }
    else if(ArrayLength* al = dynamic_cast<ArrayLength*>(expr))
    {
      generateExpression(c, al->array);
      c << "->dim";
    }
    else if(dynamic_cast<ThisExpr*>(expr))
    {
      c << "this_";
    }
    else if(TempVar* tv = dynamic_cast<TempVar*>(expr))
    {
      //in C code, this is just the temporary variable's name
      c << tv->ident;
    }
    else
    {
      //compound literal, or anything else that hasn't been covered
      cout << "*** ERROR: generateExpression not implemented for some expr subclass\n";
      INTERNAL_ERROR;
    }
  }

  void generateBlock(ostream& c, Block* b)
  {
    c << "{\n";
    //introduce local variables
    generateLocalVariables(c, b->scope);
    for(auto blockStmt : b->stmts)
    {
      generateStatement(c, b, blockStmt);
    }
    c << "}\n";
  }

  void generateStatement(ostream& c, Block* b, Statement* stmt)
  {
    //get the type of statement
    if(Block* blk = dynamic_cast<Block*>(stmt))
    {
      generateBlock(c, blk);
    }
    else if(Assign* a = dynamic_cast<Assign*>(stmt))
    {
      generateAssignment(c, b, a->lvalue, a->rvalue);
    }
    else if(CallStmt* cs = dynamic_cast<CallStmt*>(stmt))
    {
      generateExpression(c, cs->eval);
      c << ";\n";
    }
    else if(For* f = dynamic_cast<For*>(stmt))
    {
      //generate a "break" label for this loop
      string breakLabel = getIdentifier();
      Context::forBreakLabels[f] = breakLabel;
      //open a C block for loop scope's vars
      c << "{\n";
      generateLocalVariables(c, f->loopBlock->scope);
      if(f->init)
      {
        generateStatement(c, b, f->init);
      }
      //generate a while loop
      c << "while(";
      if(f->condition)
      {
        generateExpression(c, f->condition);
      }
      else
      {
        c << '1';
      }
      c << ")\n{\n";
      //generate loop body statements
      for(auto loopStmt : f->loopBlock->stmts)
      {
        generateStatement(c, b, loopStmt);
      }
      if(f->increment)
      {
        //enclose increment statement in a block so that
        //the automatic semicolon is OK
        generateStatement(c, b, f->increment);
      }
      c << "}\n";
      //outside the loop, put break label
      c << breakLabel << ":;\n";
      c << "}\n";
    }
    else if(While* w = dynamic_cast<While*>(stmt))
    {
      c << "while(";
      generateExpression(c, w->condition);
      c << ")\n";
      c << "{\n";
      generateBlock(c, w->loopBlock);
      c << "}\n";
    }
    else if(If* ii = dynamic_cast<If*>(stmt))
    {
      c << "if(";
      generateExpression(c, ii->condition);
      c << ")\n{\n";
      generateStatement(c, b, ii->body);
      c << "}\n";
    }
    else if(IfElse* ie = dynamic_cast<IfElse*>(stmt))
    {
      c << "if(";
      generateExpression(c, ie->condition);
      c << ")\n";
      generateStatement(c, b, ie->trueBody);
      c << "else\n";
      generateStatement(c, b, ie->falseBody);
    }
    else if(Return* r = dynamic_cast<Return*>(stmt))
    {
      if(r->value)
      {
        c << "return ";
        generateExpression(c, r->value);
        c << ";\n";
      }
      else
      {
        c << "return;\n";
      }
    }
    else if(Break* brk = dynamic_cast<Break*>(stmt))
    {
      //if a While, just use C break (always same semantics as Onyx)
      if(brk->breakable.is<While*>())
      {
        c << "break;\n";
      }
      else if(brk->breakable.is<For*>())
      {
        c << "goto " << Context::forBreakLabels[brk->breakable.get<For*>()] << ";\n";
      }
      else if(brk->breakable.is<Switch*>())
      {
        c << "goto " << Context::switchBreakLabels[brk->breakable.get<Switch*>()] << ";\n";
      }
    }
    else if(dynamic_cast<Continue*>(stmt))
    {
      c << "continue;\n";
    }
    else if(Print* p = dynamic_cast<Print*>(stmt))
    {
      c << "{\n";
      //first, evaluate all arguments in order (assign to shallow-copy temps)
      //this is so that side effects (e.g. out of bounds error) happen
      //before anything gets printed
      vector<string> temps;
      for(size_t i = 0; i < p->exprs.size(); i++)
      {
        string argI = getIdentifier();
        temps.push_back(argI);
        c << types[p->exprs[i]->type] << ' ' << argI << " = ";
        generateExpression(c, p->exprs[i]);
        c << ";\n";
      }
      //now print them
      for(size_t i = 0; i < p->exprs.size(); i++)
      {
        c << getPrintFunc(p->exprs[i]->type) << '(' << temps[i] << ");\n";
      }
      c << "}\n";
    }
    else if(Assertion* assertion = dynamic_cast<Assertion*>(stmt))
    {
      c << "if(";
      generateExpression(c, assertion->asserted);
      c << ")\n";
      c << "{\n";
      c << "puts(\"Assertion failed.\");\n";
      c << "exit(1);\n";
      c << "}\n";
    }
    else if(Switch* sw = dynamic_cast<Switch*>(stmt))
    {
      //C can't compare compound data structures, so
      //compare to each label value and jump directly to the proper statement
      //break is a jump to the end of switch
      //use Context::switchBreakLabel to hold this label
      c << "// Begin switch stmt\n{\n";
      string breakLabel = getIdentifier();
      Context::switchBreakLabels[sw] = breakLabel;
      //generate the jump labels
      vector<string> jumpLabels;
      for(size_t i = 0; i < sw->caseLabels.size(); i++)
      {
        jumpLabels.push_back(getIdentifier());
      }
      string defaultLabel = getIdentifier();
      //evaluate the switched expression and assign to temp
      string temp = getIdentifier();
      c << types[sw->switched->type] << ' ' << temp << " = ";
      generateExpression(c, sw->switched);
      c << ";\n";
      for(size_t i = 0; i < sw->caseLabels.size(); i++)
      {
        if(i > 0)
          c << "else ";
        c << "if(" << getEqualsFunc(sw->switched->type) << '(' << temp << ", ";
        generateExpression(c, sw->caseValues[i]);
        c << "))\n";
        c << "goto " << jumpLabels[i] << ";\n";
      }
      //else: default
      c << "else\n";
      c << "goto " << defaultLabel << ";\n";
      //generate all statements, inserting the jump labels in proper positions
      size_t labelIt = 0;
      size_t stmtIt = 0;
      for(auto swStmt : sw->block->stmts)
      {
        //generate all the labels that should go before statement #stmtIt
        while(sw->caseLabels[labelIt] == stmtIt)
        {
          c << jumpLabels[labelIt++] << ":\n";
        }
        if(sw->defaultPosition == stmtIt)
        {
          c << defaultLabel << ":\n";
        }
        generateStatement(c, sw->block, swStmt);
        stmtIt++;
      }
      while(labelIt < sw->caseLabels.size())
      {
        c << jumpLabels[labelIt++] << ":\n";
      }
      if(sw->defaultPosition == sw->block->stmts.size())
      {
        c << defaultLabel << ":\n";
      }
      c << breakLabel << ":;\n";
      c << "}\n// End switch stmt\n";
    }
    else if(Match* ma = dynamic_cast<Match*>(stmt))
    {
      //assign matched union expr to a temp
      string temp = getIdentifier();
      UnionType* ut = (UnionType*) ma->matched->type;
      c << types[ut] << ' ' << temp << " = ";
      generateExpression(c, ma->matched);
      c << ";\n";
      c << "switch(" << temp << ".option)\n{\n";
      for(size_t i = 0; i < ut->options.size(); i++)
      {
        Type* optType = ut->options[i];
        c << "case " << i << ":\n";
        c << "{\n";
        generateLocalVariables(c, ma->cases[i]->scope);
        //assign the special variable of optType
        c << vars[ma->caseVars[i]] << " = *((" << types[optType];
        c << "*) " << temp << ".data);\n";
        //generate all statements normally
        for(auto maStmt : ma->cases[i]->stmts)
        {
          generateStatement(c, ma->cases[i], maStmt);
        }
        //need to break from the C switch
        c << "break;\n}\n";
      }
      c << "}\n";
    }
    else
    {
      cout << "Didn't implement a statement type in C backend\n";
      INTERNAL_ERROR;
    }
  }

  void generateAssignment(ostream& c, Block* b, Expression* lhs, Expression* rhs)
  {
    //generateExpression can't be used with compound literals, so
    //  any case where LHS and/or RHS are compound literals are special
    //LHS is compound literal:
    //  -RHS can be another compound lit, or anything else is tuple, struct
    //LHS is variable or indexed:
    //  -RHS can be anything that matches type
    if(auto clLHS = dynamic_cast<CompoundLiteral*>(lhs))
    {
      cout << "LHS is a compound lit\n";
      //only compound literals, tuples and structs may be assigned to a compound literal
      if(auto clRHS = dynamic_cast<CompoundLiteral*>(rhs))
      {
        //copy members directly, one at a time
        for(size_t i = 0; i < clLHS->members.size(); i++)
        {
          generateAssignment(c, b, clLHS->members[i], clRHS->members[i]);
        }
      }
      else if(rhs->type->isTuple())
      {
        for(size_t i = 0; i < clLHS->members.size(); i++)
        {
          //create tuple index
          IntLiteral index(i);
          Indexed rhsMember(rhs, &index);
          generateAssignment(c, b, clLHS->members[i], &rhsMember);
        }
      }
      else if(rhs->type->isStruct())
      {
        //generate assignment for each member
        for(size_t i = 0; i < clLHS->members.size(); i++)
        {
          IntLiteral index(i);
          Indexed rhsMember(rhs, &index);
          generateAssignment(c, b, clLHS->members[i], &rhsMember);
        }
      }
    }
    else if(auto clRHS = dynamic_cast<CompoundLiteral*>(rhs))
    {
      cout << "RHS is a compound lit\n";
      //lhs may be a tuple, struct or array
      //know that lhs is not also a compound literal,
      //because that case is handled above
      if(lhs->type->isStruct())
      {
        //generate a StructMem expr for each member,
        //then generate the assignment to that
        //
        //semantic checking has already made sure that
        //compound lit members match 1-1 with struct members
        for(size_t i = 0; i < clRHS->members.size(); i++)
        {
          auto st = dynamic_cast<StructType*>(lhs->type);
          StructMem lhsMem(lhs, st->members[i]);
          generateAssignment(c, b, &lhsMem, clRHS->members[i]);
        }
      }
      else if(lhs->type->isTuple())
      {
        for(size_t i = 0; i < clRHS->members.size(); i++)
        {
          IntLiteral index(i);
          Indexed lhsMember(lhs, &index);
          generateAssignment(c, b, &index, clRHS->members[i]);
        }
      }
      else if(lhs->type->isArray())
      {
        //since an array is an lvalue, it
        //must already be allocated
        /*
        c << getDeallocFunc(lhs->type) << "(";
        generateExpression(c, lhs);
        c << ");\n";
        */
        //create the array with proper size,
        //then assign each element individually
        generateExpression(c, lhs);
        c << " = " << getAllocFunc((ArrayType*) lhs->type) << "(";
        c << clRHS->members.size() << ");\n";
        for(size_t i = 0; i < clRHS->members.size(); i++)
        {
          IntLiteral index(i);
          Indexed lhsMember(lhs, &index);
          generateAssignment(c, b, &lhsMember, clRHS->members[i]);
        }
      }
    }
    else
    {
      //direct assignment of one expression to another, where neither
      //lhs nor rhs are CompoundLiterals and rhs is not a subroutine call
      //  -call free on lhs before assignment (if necessary for its type)
      //  -if rhs is assignable, it is persistent, so need to deep copy
      //  -if rhs is not persistent, can shallow copy it
      /*
      if(lhs->assignable() && needsDealloc[lhs->type])
      {
        c << getDeallocFunc(lhs->type) << "(";
        generateExpression(c, lhs);
        c << ");\n";
      }
      */
      auto indexed = dynamic_cast<Indexed*>(lhs);
      ArrayType* lhsArray = nullptr;
      if(indexed)
        lhsArray = dynamic_cast<ArrayType*>(indexed->group->type);
      if(indexed && lhsArray)
      {
        c << getAssignFunc(lhsArray) << '(';
        generateExpression(c, indexed->group);
        c << ", ";
        generateExpression(c, rhs);
        c << ", ";
        generateExpression(c, indexed->index);
        c << ");\n";
      }
      else
      {
        generateExpression(c, lhs);
        c << " = ";
        generateExpression(c, rhs);
        c << ";\n";
      }
    }
  }

  void generateLocalVariables(ostream& c, BlockScope* bs)
  {
    for(auto& n : bs->names)
    {
      if(n.second.kind != Name::VARIABLE)
      {
        continue;
      }
      Variable* local = (Variable*) n.second.item;
      string localIdent = getIdentifier();
      vars[local] = localIdent;
      c << types[local->type] << ' ' << localIdent << " = " <<
        getInitFunc(local->type) << "(); // " << local->type->getName() <<
        ' ' << local->name << '\n';
    }
  }

  bool typeNeedsDealloc(TypeSystem::Type* t)
  {
    //lazily populate needsDealloc
    auto it = needsDealloc.find(t);
    if(it == needsDealloc.end())
    {
      bool value = false;
      if(t->isPrimitive())
      {
        value = false;
      }
      else if(auto st = dynamic_cast<StructType*>(t))
      {
        for(auto mem : st->members)
        {
          if(typeNeedsDealloc(mem->type))
          {
            value = true;
            break;
          }
        }
      }
      else if(auto tt = dynamic_cast<TupleType*>(t))
      {
        for(auto mem : tt->members)
        {
          if(typeNeedsDealloc(mem))
          {
            value = true;
            break;
          }
        }
      }
      else if(dynamic_cast<UnionType*>(t))
      {
        value = true;
      }
      else if(dynamic_cast<ArrayType*>(t))
      {
        value = true;
      }
      needsDealloc[t] = value;
      return value;
    }
    return it->second;
  }

  string getIdentifier()
  {
    //use a base-36 encoding of identCount using 0-9 A-Z
    char buf[32];
    buf[31] = 0;
    auto val = identCount;
    int iter = 30;
    for(;; iter--)
    {
      int digit = val % 36;
      if(digit < 10)
      {
        buf[iter] = '0' + digit;
      }
      else
      {
        buf[iter] = 'A' + (digit - 10);
      }
      val /= 36;
      if(val == 0)
        break;
    }
    //now buf + iter is the string
    identCount++;
    return string("o") + (buf + iter) + '_';
  }

  template<typename F>
  void walkScopeTree(F f)
  {
    vector<Scope*> visit;
    visit.push_back(global);
    while(visit.size())
    {
      Scope* s = visit.back();
      f(s);
      visit.pop_back();
      for(auto child : s->children)
      {
        visit.push_back(child);
      }
    }
  }

  string getInitFunc(Type* t)
  {
    string& typeName = types[t];
    string func = "init_" + typeName + "_";
    //additional types where init funcs should be generated vector<Type*> deps;
    if(initImpl.find(t) != initImpl.end())
    {
      return func;
    }
    initImpl.insert(t);
    Oss def;
    utilFuncDecls << typeName << "* " << func << "();\n";
    def << typeName << "* " << func << "()\n{\n";
    if(t->isEnum())
    {
      EnumType* et = (EnumType*) t;
      if(et->values.size())
      {
        def << "uint64_t* tmp = malloc(8);\n";
        def << "*tmp = " << et->values[0]->value;
        def << "return tmp;\n";
      }
      else
      {
        //0
        def << "return calloc(1, sizeof(uint64_t));\n";
      }
    }
    else if(t->isStruct() || t->isTuple())
    {
      auto st = dynamic_cast<StructType*>(t);
      auto tt = dynamic_cast<TupleType*>(t);
      def << typeName << " temp_;\n";
      if(st)
      {
        for(size_t i = 0; i < st->members.size(); i++)
        {
          def << "temp_.mem" << i << " = " <<
            getInitFunc(st->members[i]->type) << "();\n";
        }
      }
      else
      {
        for(size_t i = 0; i < tt->members.size(); i++)
        {
          def << "temp_.mem" << i << " = " <<
            getInitFunc(tt->members[i]) << "();\n";
        }
      }
      def << "return temp_;\n";
    }
    else if(t->isArray() || t->isUnion() || t->isCallable()
        || t->isPrimitive())
    {
      //an empty array should have 0 size and NULL data
      //an uninitialized union should have no data
      //uninitialized fn ptr should be NULL
      def << "return calloc(1, sizeof(" << typeName << "));\n";
    }
    def << "}\n\n";
    utilFuncDefs << def.str();
    return func;
  }

  string getCopyFunc(Type* t)
  {
    string& typeName = types[t];
    string func = "copy_" + typeName + "_";
    if(copyImpl.find(t) != copyImpl.end())
    {
      return func;
    }
    copyImpl.insert(t);
    Oss def;
    {
      Oss prototype;
      prototype << typeName << "* " << func << '(' << typeName << "* data)";
      utilFuncDecls << prototype.str() << ";\n";
      def << prototype.str() << "\n{\n";
    }
    def << typeName << "* cp = malloc(sizeof(";
    def << typeName << "));\n";
    //note: void doesn't get a copy function because it will never be called
    //cannot have variable or argument of type void (checked in middle end)
    if(t->isPrimitive())
    {
      //primitives (integers, bool, floats) are trivially copyable
      def << "memcpy(cp, data, sizeof(" << types[t] << "));\n";
    }
    else if(auto at = dynamic_cast<ArrayType*>(t))
    {
      string& subtype = types[at->subtype];
      def << subtype << "* temp = malloc(sizeof(" << subtype << ") * data.dim);\n";
      def << "for(" << size_type << " i = 0; i < data.dim; i_++)\n{\n";
      def << "temp_[i_] = " << getCopyFunc(at->subtype) << "(data->data[i]);\n";
      def << "}\n";
      def << "return ((" << typeName << ") {temp_, data_.dim});\n";
    }
    else if(auto st = dynamic_cast<StructType*>(t))
    {
      utilFuncDefs << typeName << " temp_;\n";
      for(size_t i = 0; i < st->members.size(); i++)
      {
        def << "temp_.mem" << i << " = " << getCopyFunc(st->members[i]->type) << "(data_." << st->members[i]->name << ");\n";
      }
      def << "return temp_;\n";
    }
    else if(auto ut = dynamic_cast<UnionType*>(t))
    {
      def << typeName << " temp_;\n";
      def << "temp_.option = data_.option;\n";
      def << "switch(data_.option)\n{\n";
      for(size_t i = 0; i < ut->options.size(); i++)
      {
        def << "case " << i << ":\n";
        //allocate space in temp
        string& optionType = types[ut->options[i]];
        def << "temp_.data = malloc(sizeof(" << optionType << "));\n";
        //deep copy data_'s underlying type into temp_
        def << "*((" << optionType << "*) temp_.data) = " << getCopyFunc(ut->options[i]) << "(*((" << optionType << "*) data_.data));\n";
        def << "break;\n";
      }
      def << "default:;\n}\n";
      def << "return temp_;\n";
    }
    else if(auto tt = dynamic_cast<TupleType*>(t))
    {
      //like struct, copy one member at a time
      def << typeName << " temp_;\n";
      for(size_t i = 0; i < tt->members.size(); i++)
      {
        def << "temp_.mem" << i << " = " << getCopyFunc(tt->members[i]) << "(data_.mem" << i << ");\n";
      }
      def << "return temp_;\n";
    }
    else if(dynamic_cast<CallableType*>(t))
    {
      def << "return data_;\n";
    }
    def << "return cp;\n}\n\n";
    utilFuncDefs << def.str();
    return func;
  }

  string getAllocFunc(ArrayType* t)
  {
    string func = "alloc_" + types[t] + "_";
    string& typeName = types[t];
    if(allocImpl.find(t) != allocImpl.end())
    {
      return func;
    }
    allocImpl.insert(t);
    //names of arguments
    vector<string> args;
    for(int i = 0; i < t->dims; i++)
    {
      args.push_back(getIdentifier());
    }
    //names of loop counters
    vector<string> counters;
    for(int i = 0; i < t->dims; i++)
    {
      counters.push_back(getIdentifier());
    }
    Oss def;
    {
      Oss prototype;
      prototype << typeName << ' ' << func << '(';
      for(int i = 0; i < t->dims; i++)
      {
        prototype << size_type << ' ' << args[i];
        if(i != t->dims - 1)
          prototype << ", ";
      }
      prototype << ')';
      utilFuncDecls << prototype.str() << ";\n";
      def << "inline " << prototype.str() << "\n{\n";
    }
    //create the overall array type (which will be returned at the end)
    def << typeName << " array_;\n";
    //add prototype to both util decls and defs
    Type* subtype = t->subtype;
    for(int i = 0; i < t->dims; i++)
    {
      //generate allocation
      def << "array_.data";
      for(int j = 0; j < i; j++)
      {
        def << "[" << counters[j] << "].data";
      }
      //set data
      def << " = malloc(" << args[i] << " * sizeof(" << types[subtype] << "));\n";
      //set dimensions
      def << "array_";
      for(int j = 0; j < i; j++)
      {
        def << ".data[" << counters[j] << "]";
      }
      //set data
      def << ".dim = " << args[i] << ";\n";
      //generate a loop for the ith dimension
      def << "for(" << size_type << ' ' << counters[i] << " = 0; " <<
        counters[i] << " < " << args[i] << "; "
        << counters[i] << "++)\n{\n";
      if(i == t->dims - 1)
      {
        //in innermost loop, call init() to each element of innermost array
        def << "array_";
        for(int j = 0; j <= i; j++)
        {
          def << ".data[" << counters[j] << ']';
        }
        def << " = " << getInitFunc(subtype) << "();\n";
      }
      //if not in last iteration (where subtype is not an array),
      //switch type to next-lower dimension
      if(i != t->dims - 1)
      {
        ArrayType* sub = dynamic_cast<ArrayType*>(subtype);
        subtype = sub->subtype;
      }
    }
    //close all the loops
    for(int i = 0; i < t->dims; i++)
    {
      def << "}\n";
    }
    def << "return array_;\n";
    def << "}\n\n";
    utilFuncDefs << def.str();
    return func;
  }

  string getDeallocFunc(Type* t)
  {
    string func = "free_" + types[t] + "_";
    if(deallocImpl.find(t) != deallocImpl.end())
    {
      return func;
    }
    deallocImpl.insert(t);
    string& typeName = types[t];
    //only struct, tuple, array and unions need to be freed
    utilFuncDecls << "void " << func << "(" << typeName << " data_);\n";
    Oss def;
    def << "inline void " << func << "(" << typeName << " data_)\n{\n";
    if(auto st = dynamic_cast<StructType*>(t))
    {
      for(size_t i = 0; i < st->members.size(); i++)
      {
        if(typeNeedsDealloc(st->members[i]->type))
        {
          def << getDeallocFunc(st->members[i]->type) << "(data_." << st->members[i]->type << ");\n";
        }
      }
    }
    else if(auto tt = dynamic_cast<TupleType*>(t))
    {
      for(size_t i = 0; i < tt->members.size(); i++)
      {
        if(typeNeedsDealloc(tt->members[i]))
        {
          def << getDeallocFunc(tt->members[i]) << "(data_.mem" << i << ");\n";
        }
      }
    }
    else if(auto ut = dynamic_cast<UnionType*>(t))
    {
      def << "switch(data_.option)\n{\n";
      for(size_t i = 0; i < ut->options.size(); i++)
      {
        def << "case " << i << ":\n";
        if(typeNeedsDealloc(ut->options[i]))
        {
          def << getDeallocFunc(ut->options[i]) << "(*((" << types[ut->options[i]] << "*) data_.data));\n";
        }
        def << "break;\n";
      }
      def << "free(data_.data);\n";
      def << "}\n";
    }
    else if(auto at = dynamic_cast<ArrayType*>(t))
    {
      def << "if(data_.data != NULL)\n{\n";
      //add free calls for each element, if subtype has nontrivial deallocator
      if(typeNeedsDealloc(at->subtype))
      {
        def << "for(size_t i_ = 0; i_ < data_.dim; i_++)\n{\n";
        def << getDeallocFunc(at->subtype) << "(data_.data[i_]);\n";
        def << "}\n";
      }
      def << "free(data_.data);\n";
      def << "}\n";
    }
    def << "}\n";
    utilFuncDefs << def.str();
    return func;
  }

  string getPrintFunc(Type* t)
  {
    string& typeName = types[t];
    string func = "print_" + typeName + "_";
    if(printImpl.find(t) != printImpl.end())
    {
      return func;
    }
    printImpl.insert(t);
    Oss def;
    utilFuncDecls << "void " << func << "(" << typeName << " data_);\n";
    def << "void " << func << "(" << typeName << " data_)\n{\n";
    if(t->isPrimitive())
    {
      //all primitives except bool can be printed as a single printf specifier
      //so just determine the %format
      string fmt;
      if(auto intType = dynamic_cast<IntegerType*>(t))
      {
        //printf format code
        switch(intType->size)
        {
          case 1:
            fmt = intType->isSigned ? "hhd" : "hhu";
            break;
          case 2:
            fmt = intType->isSigned ? "hd" : "hu";
            break;
          case 4:
            fmt = intType->isSigned ? "d" : "u";
            break;
          case 8:
            fmt = intType->isSigned ? "lld" : "llu";
            break;
          default:
            INTERNAL_ERROR;
        }
      }
      else if(t->isChar())
      {
        fmt = "c";
      }
      else if(t->isFloat())
      {
        fmt = "f";
      }
      def << "printf(\"%" << fmt << "\", data_);\n";
    }
    else if(t->isBool())
    {
      def << "if(data_)\nprintf(\"true\");\nelse\nprintf(\"false\");\n";
    }
    else
    {
      //compound types
      if(ArrayType* at = dynamic_cast<ArrayType*>(t))
      {
        if(at->subtype->isChar())
        {
          //t is string: write it to stdout all at once
          def << "fwrite(data_.data, 1, data_.dim, stdout);\n";
        }
        else
        {
          def << "putchar('{');\n";
          def << "for(uint64_t count_ = 0; ";
          def << "count_ < data_.dim; count_++)\n{\n";
          def << getPrintFunc(at->subtype) << "(data_.data[count_]);\n}\n";
          def << "putchar('}');\n";
        }
      }
      else if(TupleType* tt = dynamic_cast<TupleType*>(t))
      {
        def << "putchar('(');\n";
        //print each member, comma separated
        for(size_t i = 0; i < tt->members.size(); i++)
        {
          def << getPrintFunc(tt->members[i]) << "(data_.mem" << i << ");\n";
          if(i != tt->members.size() - 1)
          {
            def << "printf(\", \");\n";
          }
        }
        def << "putchar(')');\n";
      }
      else if(StructType* st = dynamic_cast<StructType*>(t))
      {
        def << "printf(\"" << st->getName() << "{\");\n";
        //print each member, comma separated
        for(size_t i = 0; i < st->members.size(); i++)
        {
          def << getPrintFunc(st->members[i]->type) << "(data_.mem" << i << ");\n";
          if(i != st->members.size() - 1)
          {
            def << "printf(\", \");\n";
          }
        }
        def << "putchar('}');\n";
      }
      else if(UnionType* ut = dynamic_cast<UnionType*>(t))
      {
        def << "printf(\"" << ut->getName() << " @%i\", data_.option);\n";
        def << "switch(data_.option)\n{\n";
        for(size_t i = 0; i < ut->options.size(); i++)
        {
          def << "case " << i << ":\n";
          def << getPrintFunc(ut->options[i]) << "(*((" << types[ut->options[i]] << ") data_.data));\n";
          def << "break;\n";
        }
        def << "default:;\n";
        def << "}\n";
      }
    }
    def << "}\n\n";
    utilFuncDefs << def.str();
    return func;
  }

  string getConvertFunc(Type* out, Type* in)
  {
    string func = "convert_" + types[out] + "_" + types[in] + "_";
    pair<Type*, Type*> typePair(out, in);
    if(convertImpl.find(typePair) != convertImpl.end())
    {
      return func;
    }
    convertImpl.insert(typePair);
    Oss def;
    {
      Oss prototype;
      prototype << types[out] << ' ' << func << '(' << types[in] << " in_)";
      utilFuncDecls << prototype.str() << ";\n";
      def << "inline " << prototype.str() << "\n{\n";
    }
    //All supported type conversions:
    //  (case 1) -All primitives can be converted to each other trivially
    //    -floats/doubles truncated to integer as in C
    //    -ints converted to each other as in C
    //    -char treated as integer
    //    -any number converted to bool with nonzero being true
    //  (case 2) -Out = struct: in = struct or tuple
    //  (case 3) -Out = array: in = struct, tuple or array
    //  (case 4) -Out = map: in = map, array, or tuple
    //    -in = map: convert keys to keys and values to values;
    //      since maps are unordered, key conflicts are UB
    //    -in = array/tuple: key is int, values converted to values
    //    -in = struct: key is string, value 
    //  (case 2) -Out = tuple: in = struct or tuple
    //conversion from one primitive to another is same semantics as C
    if(in->isPrimitive() && out->isPrimitive())
    {
      if(out == TypeSystem::primitives[Parser::TypeNT::BOOL])
        def << "return in_ != 0;\n";
      else
        def << "return (" << types[out] << ") in_;\n";
    }
    else if((out->isStruct() || out->isTuple()) &&
        (in->isStruct() || in->isTuple()))
    {
      StructType* inStruct = dynamic_cast<StructType*>(in);
      StructType* outStruct = dynamic_cast<StructType*>(out);
      TupleType* inTuple = dynamic_cast<TupleType*>(in);
      TupleType* outTuple = dynamic_cast<TupleType*>(out);
      def << types[out] << " out_;\n";
      //deep copy members, one at a time
      //do explicit conversion where necessary
      size_t n = 0;
      if(outStruct)
        n = outStruct->members.size();
      else
        n = outTuple->members.size();
      for(size_t i = 0; i < n; i++)
      {
        Type* inMem;
        Type* outMem;
        if(inStruct)
          inMem = inStruct->members[i]->type;
        else
          inMem = inTuple->members[i];
        if(outStruct)
          outMem = outStruct->members[i]->type;
        else
          outMem = outTuple->members[i];
        if(inMem == outMem)
        {
          def << "out_.mem" << i << " = " << getCopyFunc(inMem) << '(' <<
            "in_.mem" << i << ");\n";
        }
        else
        {
          def << "out_.mem" << i << " = " << getConvertFunc(outMem, inMem) <<
            '(' << "in_.mem" << i << ");\n";
        }
      }
      def << "return out_;\n";
    }
    else if(out->isArray())
    {
      ArrayType* outArray = (ArrayType*) out;
      //1 of these 3 pointers will be non-null
      StructType* inStruct = dynamic_cast<StructType*>(in);
      TupleType* inTuple = dynamic_cast<TupleType*>(in);
      ArrayType* inArray = dynamic_cast<ArrayType*>(in);
      //first, allocate correctly sized array
      def << types[out] << " out_ = " << getAllocFunc(outArray) << '(';
      if(inStruct)
      {
        def << inStruct->members.size();
      }
      else if(inTuple)
      {
        def << inTuple->members.size();
      }
      else
      {
        def << "in_.dim";
      }
      def << ");\n";
      //copy members, converting as necessary
      Type* outSubtype = outArray->subtype;
      if(inStruct || inTuple)
      {
        size_t n = inStruct ? inStruct->members.size() : inTuple->members.size();
        for(size_t i = 0; i < n; i++)
        {
          Type* inMem = nullptr;
          if(inStruct)
            inMem = inStruct->members[i]->type;
          else
            inMem = inTuple->members[i];
          def << "out_.data[" << i << " = ";
          if(outSubtype == inMem)
          {
            def << getCopyFunc(outSubtype);
          }
          else
          {
            def << getConvertFunc(outSubtype, inMem);
          }
          def << "(in_.mem" << i << ");\n";
        }
      }
      else
      {
        Type* inSubtype = inArray->subtype;
        //array: generate a C loop that copies or converts members
        def << "for(" << size_type << " i_ = 0; i_ < in_.dim; i_++)\n{\n";
        def << "in_[i_] = ";
        if(outSubtype == inSubtype)
          def << getCopyFunc(outSubtype);
        else
          def << getConvertFunc(outSubtype, inSubtype);
        def << "(in_.data[i]);\n";
        def << "}\n";
      }
      def << "return out_;\n";
    }
    else if(out->isUnion())
    {
      UnionType* ut = (UnionType*) out;
      int option = 0;
      for(size_t i = 0; i < ut->options.size(); i++)
      {
        if(ut->options[i]->canConvert(in))
        {
          option = i;
          break;
        }
      }
      Type* opType = ut->options[option];
      def << types[opType] << "* temp_ = malloc(sizeof(";
      def << types[opType] << "));\n";
      if(opType == in)
      {
        def << "*temp_ = " << getCopyFunc(in) << "(in_);\n";
      }
      else
      {
        def << "*temp_ = " << getConvertFunc(opType, in) << "(in_);\n";
      }
      //now return union with correct tag and temp_ as the data
      def << "return ((" << types[out] << ") {temp_, " << option << "});\n";
    }
    else if(out->isMap())
    {
      cout << "Converting to/from maps not yet supported by C backend\n";
      INTERNAL_ERROR;
    }
    def << "}\n\n";
    utilFuncDefs << def.str();
    return func;
  }

  string getEqualsFunc(Type* t)
  {
    string& typeName = types[t];
    string func = "equals_" + typeName + "_";
    if(equalsImpl.find(t) != equalsImpl.end())
    {
      return func;
    }
    equalsImpl.insert(t);
    Oss def;
    Oss prototype;
    prototype << "bool " << func << '(' << typeName << " lhs_, " << typeName << " rhs_)";
    utilFuncDecls << prototype.str() << ';';
    def << prototype.str() << "\n{\n";
    if(t->isPrimitive() || t->isCallable())
    {
      def << "return lhs_ == rhs_;\n";
    }
    else if(StructType* st = dynamic_cast<StructType*>(t))
    {
      for(size_t i = 0; i < st->members.size(); i++)
      {
        Type* mem = st->members[i]->type;
        def << "if(!" << getEqualsFunc(mem) << "(lhs_.mem" << i <<
          ", rhs_.mem" << i << "))\nreturn false;\n";
      }
      def << "return true;\n";
    }
    else if(TupleType* tt = dynamic_cast<TupleType*>(t))
    {
      for(size_t i = 0; i < tt->members.size(); i++)
      {
        def << "if(!" << getEqualsFunc(tt->members[i]) << "(lhs_.mem" << i <<
          ", rhs_.mem" << i << "))\nreturn false;\n";
      }
      def << "return true;\n";
    }
    else if(ArrayType* at = dynamic_cast<ArrayType*>(t))
    {
      def << "if(lhs_.dim != rhs_.dim)\nreturn false;\n";
      def << "for(" << size_type << " i_ = 0; i_ < lhs_.dim; i_++)\n";
      def << "{\nif(!" << getEqualsFunc(at->subtype) << "(lhs_.data[i_], rhs_.data[i_]))\n";
      def << "return false;}\n";
      def << "return true;\n";
    }
    else if(UnionType* ut = dynamic_cast<UnionType*>(t))
    {
      //lhs and rhs must be exactly the same union type,
      //so compare tags and then data
      def << "if(lhs_.option != rhs_.option)\n{\nreturn false;\n}\n";
      //need to compare underlying data for the actual type
      def << "switch(lhs_.option)\n{\n";
      for(size_t i = 0; i < ut->options.size(); i++)
      {
        def << "case " << i << ":\n";
        def << "return " << getEqualsFunc(ut->options[i]) << "*((" <<
          types[ut->options[i]] << ") lhs_.data), *((" << types[ut->options[i]] << ") rhs_.data));\n";
      }
      def << "default: return false;\n}\n";
      def << "return false;\n";
    }
    else if(MapType* mt = dynamic_cast<MapType*>(t))
    {
      cout << "maps not implemented yet\n";
      INTERNAL_ERROR;
    }
    else
    {
      cout << "some type hasn't been compared yet, C backend:" << __LINE__ << "\n";
      INTERNAL_ERROR;
    }
    def << "}\n";
    utilFuncDefs << def.str();
    return func;
  }

  string getLessFunc(Type* t)
  {
    string& typeName = types[t];
    string func = "less_" + typeName + "_";
    if(lessImpl.find(t) != lessImpl.end())
    {
      return func;
    }
    lessImpl.insert(t);
    Oss def;
    Oss prototype;
    prototype << "bool " << func << '(' << typeName << " lhs_, " << typeName << " rhs_)";
    utilFuncDecls << prototype.str() << ';';
    def << prototype.str() << "\n{\n";
    if(t->isPrimitive() || t->isCallable())
    {
      if(t->isBool())
        def << "return !lhs_ && rhs_;\n";
      else
        def << "return lhs_ < rhs_;\n";
    }
    else if(StructType* st = dynamic_cast<StructType*>(t))
    {
      for(size_t i = 0; i < st->members.size(); i++)
      {
        Type* mem = st->members[i]->type;
        def << "if(" << getLessFunc(mem) << "(lhs_.mem" << i <<
          ", rhs_.mem" << i << "))\nreturn true;\n";
        def << "else if(" << getLessFunc(mem) << "(rhs_.mem" << i <<
          ", rhs_.mem" << i << "))\nreturn false;\n";
      }
      def << "return false;\n";
    }
    else if(TupleType* tt = dynamic_cast<TupleType*>(t))
    {
      for(size_t i = 0; i < tt->members.size(); i++)
      {
        def << "if(" << getLessFunc(tt->members[i]) << "(lhs_.mem" << i <<
          ", rhs_.mem" << i << "))\nreturn true;\n";
        def << "else if(" << getLessFunc(tt->members[i]) << "(rhs_.mem" << i <<
          ", rhs_.mem" << i << "))\nreturn false;\n";
      }
      def << "return false;\n";
    }
    else if(ArrayType* at = dynamic_cast<ArrayType*>(t))
    {
      def << "if(lhs_.dim < rhs_.dim)\nreturn true;\n";
      def << "else if(lhs_.dim > rhs_.dim)\nreturn false;\n";
      def << "for(" << size_type << " i_ = 0; i_ < lhs_.dim; i_++)\n";
      def << "{\n";
      def << "if(" << getLessFunc(at->subtype) << "(lhs_.data[i_], rhs_.data[i_]))\n";
      def << "return true;";
      def << "else if(" << getLessFunc(at->subtype) << "(rhs_.data[i_], lhs_.data[i_]))\n";
      def << "return false;";
      def << "}\n";
      def << "return false;\n";
    }
    else if(UnionType* ut = dynamic_cast<UnionType*>(t))
    {
      //lhs and rhs must be exactly the same union type,
      //so compare tags and then data
      def << "if(lhs_.option < rhs_.option)\nreturn true;\n";
      def << "else if(lhs_.option > rhs_.option)\nreturn true;\n";
      //need to compare underlying data for the actual type
      def << "switch(lhs_.option)\n{\n";
      for(size_t i = 0; i < ut->options.size(); i++)
      {
        def << "case " << i << ":\n";
        def << "return " << getLessFunc(ut->options[i]) << "*((" <<
          types[ut->options[i]] << ") lhs_.data), *((" << types[ut->options[i]] << ") rhs_.data));\n";
      }
      def << "default: return false;\n}\n";
      def << "return false;\n";
    }
    else if(MapType* mt = dynamic_cast<MapType*>(t))
    {
      cout << "maps not implemented yet\n";
      INTERNAL_ERROR;
    }
    else
    {
      cout << "some type hasn't been compared yet, C backend:" << __LINE__ << "\n";
      INTERNAL_ERROR;
    }
    def << "}\n\n";
    utilFuncDefs << def.str();
    return func;
  }

  string getConcatFunc(ArrayType* at)
  {
    string& typeName = types[at];
    string func = "concat_" + typeName + '_';
    if(concatImpl.find(at) != concatImpl.end())
    {
      return func;
    }
    concatImpl.insert(at);
    Oss prototype;
    prototype << typeName << ' ' << func << '(' << typeName;
    prototype << " lhs_, " << typeName << " rhs_)";
    utilFuncDecls << prototype.str() << ";\n";
    Oss def;
    def << prototype.str() << "\n{\n";
    //allocate new array "rv_"
    Type* subtype = at->subtype;
    def << typeName << " rv_ = ((" << typeName <<
      ") {malloc((lhs_.dim + rhs_.dim) * sizeof(" <<
      types[subtype] << ")), lhs_.dim + rhs_.dim});\n";
    def << "for(size_t i_ = 0; i_ < lhs_.dim; i_++)\n{\n";
    def << "rv_.data[i_] = " << getCopyFunc(subtype) << "(lhs_.data[i_]);\n";
    def << "}\n";
    def << "for(size_t i_ = 0; i_ < rhs_.dim; i_++)\n{\n";
    def << "rv_.data[i_ + lhs_.dim] = " << getCopyFunc(subtype) <<
      "(rhs_.data[i_]);\n";
    def << "}\n";
    def << "return rv_;\n}\n\n";
    utilFuncDefs << def.str();
    return func;
  }

  string getAppendFunc(TypeSystem::ArrayType* at)
  {
    string& typeName = types[at];
    string func = "append_" + typeName + '_';
    if(appendImpl.find(at) != appendImpl.end())
    {
      return func;
    }
    appendImpl.insert(at);
    Oss prototype;
    Type* subtype = at->subtype;
    prototype << typeName << ' ' << func << '(' << typeName;
    prototype << " lhs_, " << types[subtype] << " rhs_)";
    utilFuncDecls << prototype.str() << ";\n";
    Oss def;
    def << prototype.str() << "\n{\n";
    //allocate new array "rv_"
    def << typeName << " rv_ = ((" << typeName <<
      ") {malloc((lhs_.dim + 1) * sizeof(" <<
      types[subtype] << ")), lhs_.dim + 1});\n";
    def << "for(size_t i_ = 0; i_ < lhs_.dim; i_++)\n{\n";
    def << "rv_.data[i_] = " << getCopyFunc(subtype) << "(lhs_.data[i_]);\n";
    def << "}\n";
    def << "rv_.data[lhs_.dim] = " << getCopyFunc(subtype) << "(rhs_);\n";
    def << "return rv_;\n}\n\n";
    utilFuncDefs << def.str();
    return func;
  }

  string getPrependFunc(TypeSystem::ArrayType* at)
  {
    string& typeName = types[at];
    string func = "prepend_" + typeName + '_';
    if(prependImpl.find(at) != prependImpl.end())
    {
      return func;
    }
    prependImpl.insert(at);
    Oss prototype;
    Type* subtype = at->subtype;
    prototype << typeName << ' ' << func << '(' << types[subtype] << " lhs_, ";
    prototype << typeName << " rhs_)";
    utilFuncDecls << prototype.str() << ";\n";
    Oss def;
    def << prototype.str() << "\n{\n";
    //allocate new array "rv_"
    def << typeName << " rv_ = ((" << typeName <<
      ") {malloc((rhs_.dim + 1) * sizeof(" <<
      types[subtype] << ")), rhs_.dim + 1});\n";
    def << "rv_.data[0] = " << getCopyFunc(subtype) << "(lhs_);\n";
    def << "for(size_t i_ = 0; i_ < rhs_.dim; i_++)\n{\n";
    def << "rv_.data[i_ + 1] = " << getCopyFunc(subtype) << "(rhs_.data[i_]);\n";
    def << "}\n";
    def << "return rv_;\n}\n\n";
    utilFuncDefs << def.str();
    return func;
  }

  string getAccessFunc(ArrayType* at)
  {
    string& typeName = types[at];
    string func = "access_" + typeName + '_';
    if(accessImpl.find(at) != accessImpl.end())
    {
      return func;
    }
    accessImpl.insert(at);
    Oss prototype;
    Type* subtype = at->subtype;
    prototype << types[subtype] << ' ' << func << '(' << typeName << " arr_, ";
    prototype << size_type << " index_)";
    utilFuncDecls << prototype.str() << ";\n";
    Oss def;
    def << prototype.str() << "\n{\n";
    //note: size_type is unsigned so no need to check for >= 0
    def << "if(index_ >= arr_.dim)\n{\n";
    def << "char buf[64];\n";
    def << "sprintf(buf, \"array index %u out of bounds\", index_);\n";
    def << "panic_(buf);\n";
    def << "}\n";
    def << "return arr_.data[index_];\n";
    def << "}\n\n";
    utilFuncDefs << def.str();
    return func;
  }

  string getAssignFunc(ArrayType* at)
  {
    string& typeName = types[at];
    string func = "assign_" + typeName + '_';
    if(assignImpl.find(at) != assignImpl.end())
    {
      return func;
    }
    assignImpl.insert(at);
    Oss prototype;
    Type* subtype = at->subtype;
    prototype << "void " << func << '(' << typeName << " arr_, ";
    prototype << types[subtype] << " data_, " << size_type << " index_)";
    utilFuncDecls << prototype.str() << ";\n";
    Oss def;
    def << prototype.str() << "\n{\n";
    //note: size_type is unsigned so no need to check for >= 0
    def << "if(index_ >= arr_.dim)\n{\n";
    def << "char buf[64];\n";
    def << "sprintf(buf, \"array index %u out of bounds\", index_);\n";
    def << "panic_(buf);\n";
    def << "}\n";
    def << "arr_.data[index_] = " << getCopyFunc(subtype) << "(data_);\n";
    def << "}\n\n";
    utilFuncDefs << def.str();
    return func;
  }

  string getHashFunc(TypeSystem::Type* t)
  {
    string& typeName = types[t];
    string func = "hash_" + typeName + '_';
    if(hashImpl.find(t) != hashImpl.end())
    {
      return func;
    }
    hashImpl.insert(t);
    Oss prototype;
    prototype << "uint32_t " << func << "(void* val_)";
    utilFuncDecls << prototype.str() << ";\n";
    Oss def;
    def << prototype.str() << "\n{\n";
    //In the FNV-1a hash, the offset basis and prime to use:
    const unsigned BASIS = 2166136261;
    const unsigned PRIME = 16777619;
    def << "uint32_t h_ = " << BASIS << ";\n";
    if(t->isNumber())
    {
      //POD: can just deref each byte of the right size,
      //and statically generate the hash computation with each byte
      int size = 0;
      if(auto intType = dynamic_cast<IntegerType*>(t))
        size = intType->size;
      else if(auto floatType = dynamic_cast<FloatType*>(t))
        size = floatType->size;
      else if(dynamic_cast<EnumType*>(t))
        size = 8;
      else if(dynamic_cast<CharType*>(t))
        size = 1;
      else
      {
        INTERNAL_ERROR;
      }
      for(int i = 0; i < size; i++)
      {
        def << "hash_ = hash_ ^ *(((char*) val_) + " << i << ");\n";
        def << "hash_ = hash_ * " << PRIME << ";\n";
      }
    }
    else if(auto at = dynamic_cast<ArrayType*>(t))
    {
      def << types[t] << "* tmp_ = (" << types[t] << "*) val_;\n";
      def << "for(" << size_type << " i_ = 0; i_ < tmp_->dim; i_++)\n{\n";
      def << "hash_ ^= " << getHashFunc(at->subtype) << "(&(tmp_->data[i_]));\n";
      def << "}\n";
    }
    else if(t->isStruct() || t->isTuple())
    {
      auto st = dynamic_cast<StructType*>(t);
      auto tt = dynamic_cast<TupleType*>(t);
      int numMems = 0;
      if(st)
        numMems = st->members.size();
      else
        numMems = tt->members.size();
      for(int i = 0; i < numMems; i++)
      {
        Type* memType = nullptr;
        if(st)
          memType = st->members[i]->type;
        else
          memType = tt->members[i];
        def << "hash_ ^= " << getHashFunc(memType) << "(&(tmp_->mem";
        def << i << "));\n";
      }
    }
    else if(dynamic_cast<MapType*>(t))
    {
      //TODO
    }
    def << "return hash_;\n}\n\n";
    utilFuncDefs << def.str();
    return func;
  }

  void generateSectionHeader(ostream& c, string name)
  {
    c << "//////////////////////////////\n";
    int space = 13 - name.length() / 2;
    c << "//";
    for(int i = 0; i < space; i++)
      c << ' ';
    c << name;
    for(int i = 2 + space + name.length(); i < 28; i++)
      c << ' ';
    c << "//\n";
    c << "//////////////////////////////\n\n";
  }
}

