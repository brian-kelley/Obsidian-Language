#include "C_Backend.hpp"

using namespace TypeSystem;

map<Type*, string> types;
map<Type*, bool> typesImplemented;
map<Subroutine*, string> subrs;
map<Variable*, string> vars;
map<Type*, bool> needsDealloc;   //whether each type needs a non-trivial deallocator
size_t identCount;
ofstream c;
//different stringstreams to build the C file (in this order)
Oss typeDecls;      //all typedefs (including forward-declarations as necessary)
Oss varDecls;       //all global/static variables
Oss utilFuncDecls;  //util functions are print, array creation, deep copy, etc
Oss utilFuncDefs;
Oss funcDecls;      //the actual subroutines in the onyx program
Oss funcDefs;

//The C type to use for array indices (could possibly be uint64_t for more portability)
const char* size_type = "uint32_t";

namespace C
{
  void generate(string outputStem, bool keep)
  {
    cout << "Starting C backend.\n";
    string cName = outputStem + ".c";
    string exeName = outputStem + ".exe";
    typeDecls = Oss();
    varDecls = Oss();
    utilFuncDecls = Oss();
    utilFuncDefs = Oss();
    funcDecls = Oss();
    funcDefs = Oss();
    cout << "  > Generating type declarations\n";
    generateSectionHeader(typeDecls, "Type Decls");
    genTypeDecls();
    cout << "  > Generating global funcs\n";
    generateSectionHeader(varDecls, "Global Variables");
    genGlobals();
    cout << "  > Generating init funcs\n";
    generateSectionHeader(utilFuncDecls, "Type init functions");
    generateSectionHeader(utilFuncDefs, "Type init functions");
    generateInitFuncs();
    utilFuncDecls << "\n";
    utilFuncDefs << "\n";
    cout << "  > Generating print funcs\n";
    generateSectionHeader(utilFuncDecls, "Type print functions");
    generateSectionHeader(utilFuncDefs, "Type print functions");
    generatePrintFuncs();
    utilFuncDecls << "\n";
    utilFuncDefs << "\n";
    cout << "  > Generating copy funcs\n";
    generateSectionHeader(utilFuncDecls, "Type copy functions");
    generateSectionHeader(utilFuncDefs, "Type copy functions");
    generateCopyFuncs();
    utilFuncDecls << "\n";
    utilFuncDefs << "\n";
    cout << "  > Generating array allocation funcs\n";
    generateSectionHeader(utilFuncDecls, "Type alloc functions");
    generateSectionHeader(utilFuncDefs, "Type alloc functions");
    generateAllocFuncs();
    utilFuncDecls << "\n";
    utilFuncDefs << "\n";
    cout << "  > Generating free funcs\n";
    generateSectionHeader(utilFuncDecls, "Type free functions");
    generateSectionHeader(utilFuncDefs, "Type free functions");
    generateDeallocFuncs();
    utilFuncDecls << "\n";
    utilFuncDefs << "\n";
    cout << "  > Generating Onyx subroutines\n";
    generateSectionHeader(funcDecls, "Functions and Procedures");
    generateSectionHeader(funcDefs, "Functions and Procedures");
    genSubroutines();
    c = ofstream(cName);
    c << "//--- " << outputStem << ".c, generated by the Onyx Compiler ---//\n\n";
    //genCommon writes directly to the c stream
    genCommon();
    //write types, vars, func decls, func defs in the ostringstreams
    c.write(typeDecls.str().c_str(), typeDecls.tellp());
    c << "\n\n";
    c.write(varDecls.str().c_str(), varDecls.tellp());
    c << "\n\n";
    c.write(utilFuncDecls.str().c_str(), utilFuncDecls.tellp());
    c << "\n\n";
    c.write(utilFuncDefs.str().c_str(), utilFuncDefs.tellp());
    c << "\n\n";
    c.write(funcDecls.str().c_str(), funcDecls.tellp());
    c << "\n\n";
    c.write(funcDefs.str().c_str(), funcDefs.tellp());
    c << '\n';
    cout << "  > Done, wrote " << c.tellp() << " bytes of C source code\n";
    c.close();
    //wait for cc to terminate
    bool compileSuccess = runCommand(string("gcc") + " --std=c99 -Os -ffast-math -fassociative-math -o " + exeName + ' ' + cName + " &> /dev/null");
    if(!keep)
    {
      remove(cName.c_str());
    }
    if(!compileSuccess)
    {
      ERR_MSG("C compiler encountered error.");
    }
  }

  void genCommon()
  {
    c << "#include \"stdio.h\"\n";
    c << "#include \"stdlib.h\"\n";
    c << "#include \"math.h\"\n";
    c << "#include \"string.h\"\n";
    c << "#include \"stdint.h\"\n";
    c << "#include \"stdbool.h\"\n";
    c << '\n';
    c << "char* strdup_(const char* str) \n";
    c << "{\n";
    c << "char* temp = malloc(1 + strlen(str)); \n";
    c << "strcpy(temp, str);\n";
    c << "return temp;\n";
    c << "}\n\n";
  }

  void genTypeDecls()
  {
    //A list of all types
    vector<Type*> allTypes;
    for(auto prim : TypeSystem::primitives)
    {
      allTypes.push_back(prim);
    }
    //add all scoped types
    walkScopeTree([&] (Scope* s) -> void
      {
        for(auto& t : s->names)
        {
          switch(t.second.kind)
          {
            //don't process TYPEDEF here because aliases
            //are never used directly in the IR
            case Name::STRUCT:
            case Name::BOUNDED_TYPE:
            case Name::ENUM:
              allTypes.push_back((Type*) t.second.item);
              break;
            default:;
          }
        }
      });
    //add all non-scoped types
    for(auto tt : TypeSystem::tuples)
    {
      allTypes.push_back(tt);
    }
    for(auto ut : TypeSystem::unions)
    {
      allTypes.push_back(ut);
    }
    for(auto mt : TypeSystem::maps)
    {
      allTypes.push_back(mt);
    }
    for(auto at : TypeSystem::arrays)
    {
      allTypes.push_back(at);
    }
    for(auto bt : TypeSystem::boundedTypes)
    {
      //bounded types are implemented as void*
      typesImplemented[bt] = true;
      types[bt] = "void*";
    }
    //primitives (string is a struct, all others are C primitives)
    types[TypeSystem::primNames["void"]] = "void";
    types[TypeSystem::primNames["bool"]] = "bool";
    types[TypeSystem::primNames["char"]] = "char";
    types[TypeSystem::primNames["byte"]] = "int8_t";
    types[TypeSystem::primNames["ubyte"]] = "uint8_t";
    types[TypeSystem::primNames["short"]] = "int16_t";
    types[TypeSystem::primNames["ushort"]] = "uint16_t";
    types[TypeSystem::primNames["int"]] = "int32_t";
    types[TypeSystem::primNames["uint"]] = "uint32_t";
    types[TypeSystem::primNames["long"]] = "int64_t";
    types[TypeSystem::primNames["ulong"]] = "uint64_t";
    types[TypeSystem::primNames["float"]] = "float";
    types[TypeSystem::primNames["double"]] = "double";
    //forward-declare all compound types
    for(auto t : allTypes)
    {
      if(t->isPrimitive())
      {
        //primitives are already implemented (done above)
        typesImplemented[t] = true;
      }
      else
      {
        //get an identifier for type t
        string ident = getIdentifier();
        types[t] = ident;
        typesImplemented[t] = false;
        //forward-declare the type
        typeDecls << "typedef struct " << ident << ' ' << ident << "; //" << t->getName() << '\n';
      }
    }
    typeDecls << '\n';
    //implement all compound types
    for(auto t : allTypes)
    {
      if(!t->isPrimitive() && !typesImplemented[t])
      {
        generateCompoundType(typeDecls, types[t], t);
      }
    }
    typeDecls << '\n';
  }

  void genGlobals()
  {
    int numGlobals = 0;
    walkScopeTree([&] (Scope* s) -> void
      {
        if(dynamic_cast<BlockScope*>(s))
        {
          //no local variables
          return;
        }
        for(auto n : s->names)
        {
          if(n.second.kind != Name::VARIABLE)
          {
            continue;
          }
          Variable* v = (Variable*) n.second.item;
          if(v->isMember)
          {
            return;
          }
          string ident = getIdentifier();
          vars[v] = ident;
          varDecls << types[v->type] << " " << ident << "; //" << v->name << '\n';
          numGlobals = 0;
        }
      });
    if(numGlobals)
    {
      varDecls << '\n';
    }
  }

  void genSubroutines()
  {
    //forward-declare all subroutines
    walkScopeTree([&] (Scope* s) -> void
      {
        for(auto& n : s->names)
        {
          //main() needs special handling so skip it here
          if(n.second.kind != Name::SUBROUTINE || n.first == "main")
          {
            continue;
          }
          Subroutine* sub = (Subroutine*) n.second.item;
          string ident = getIdentifier();
          subrs[sub] = ident;
          //all C functions except main are static
          //(private symbols, might save some time when linking)
          funcDecls << "static ";
          funcDecls << types[sub->type->returnType] << ' ' << ident << '(';
          for(size_t i = 0; i < sub->args.size(); i++)
          {
            Variable* arg = sub->args[i];
            if(i != 0)
            {
              funcDecls << ", ";
            }
            string argName = getIdentifier();
            vars[arg] = ident;
            funcDecls << types[arg->type] << ' ' << argName;
          }
          funcDecls << ");\n";
        }
      });
    //implement all subroutines
    walkScopeTree([&] (Scope* s) -> void
      {
        for(auto& n : s->names)
        {
          if(n.second.kind != Name::SUBROUTINE || n.first == "main")
          {
            continue;
          }
          auto sub = (Subroutine*) n.second.item;
          funcDefs << types[sub->type->returnType] << ' ' << subrs[sub] << '(';
          for(size_t i = 0; i < sub->args.size(); i++)
          {
            auto arg = sub->args[i];
            if(i != 0)
            {
              funcDefs << ", ";
            }
            string argName = getIdentifier();
            vars[arg] = argName;
            funcDefs << types[arg->type] << ' ' << argName;
          }
          funcDefs << ")\n";
          generateBlock(funcDefs, sub->body);
          funcDefs << '\n';
        }
      });
    genMain((Subroutine*) global->names["main"].item);
  }

  void genMain(Subroutine* m)
  {
    funcDefs << "int main(";
    if(m->args.size() == 1)
    {
      //one argument: array of strings
      funcDefs << types[getArrayType(primitives[Parser::TypeNT::CHAR], 2)];
      Variable* arg = m->args[0];
      vars[arg] = getIdentifier();
      funcDefs << ' ' << vars[arg] << ")\n{\n";
    }
    else
    {
      funcDefs << ")\n{\n";
    }
    //generate local variables
    generateLocalVariables(funcDefs, m->body->scope);
    //generate all statements like normal (one at a time)
    for(auto stmt : m->body->stmts)
    {
      generateStatement(funcDefs, m->body, stmt);
    }
    //if main was declared void, add "return 0" to avoid warning
    //(because C return type is always int)
    if(m->type->returnType == primitives[Parser::TypeNT::VOID])
    {
      funcDefs << "return 0;\n";
    }
    funcDefs << "}\n";
  }

  void generateExpression(ostream& c, Expression* expr)
  {
    //Expressions in C mostly depend on the subclass of expr
    if(UnaryArith* unary = dynamic_cast<UnaryArith*>(expr))
    {
      c << '(';
      c << operatorTable[unary->op];
      c << '(';
      generateExpression(c, unary->expr);
      c << ')';
      c << ')';
    }
    else if(BinaryArith* binary = dynamic_cast<BinaryArith*>(expr))
    {
      //fully parenthesize binary exprs so that it works
      //in case onyx ends up with different precedence than C
      c << "((";
      generateExpression(c, binary->lhs);
      c << ')';
      c << operatorTable[binary->op];
      c << '(';
      generateExpression(c, binary->rhs);
      c << "))";
    }
    else if(IntLiteral* intLit = dynamic_cast<IntLiteral*>(expr))
    {
      //all int literals are unsigned
      c << intLit->value << "U";
      if(intLit->value >= 0xFFFFFFFF)
      {
        c << "ULL";
      }
    }
    else if(FloatLiteral* floatLit = dynamic_cast<FloatLiteral*>(expr))
    {
      //all float lits have type double, so never use "f" suffix
      c << floatLit->value;
    }
    else if(StringLiteral* stringLit = dynamic_cast<StringLiteral*>(expr))
    {
      //generate a char[] struct using C struct literal
      c << "((" << types[TypeSystem::getArrayType(primNames["char"], 1)] << ") {" << stringLit->value.length() << ", strdup_(\"";
      //generate the characters of the string literal one at a time, using escapes as needed
      for(char ch : stringLit->value)
      {
        c << generateChar(ch);
      }
      c << "\")})";
    }
    else if(CharLiteral* charLit = dynamic_cast<CharLiteral*>(expr))
    {
      c << '\'';
      c << generateChar(charLit->value);
      c << '\'';
    }
    else if(BoolLiteral* boolLit = dynamic_cast<BoolLiteral*>(expr))
    {
      if(boolLit->value)
        c << "true";
      else
        c << "false";
    }
    else if(Indexed* indexed = dynamic_cast<Indexed*>(expr))
    {
      //Indexed expression must be either a tuple or array
      auto indexedType = indexed->group->type;
      if(dynamic_cast<ArrayType*>(indexedType))
      {
        c << '(';
        generateExpression(c, indexed->group);
        c << ".data[";
        generateExpression(c, indexed->index);
        c << "])";
      }
      else if(dynamic_cast<TupleType*>(indexedType))
      {
        //tuple: simply reference the requested member
        c << '(';
        generateExpression(c, indexed->group);
        //index must be an IntLiteral (has already been checked)
        c << ").mem" << dynamic_cast<IntLiteral*>(indexed)->value << ')';
      }
    }
    else if(CallExpr* call = dynamic_cast<CallExpr*>(expr))
    {
      c << "(";
      generateExpression(c, call->callable);
      c << ")(";
      for(auto arg : call->args)
      {
        generateExpression(c, arg);
      }
      c << ')';
    }
    else if(VarExpr* var = dynamic_cast<VarExpr*>(expr))
    {
      c << vars[var->var];
    }
    else if(NewArray* na = dynamic_cast<NewArray*>(expr))
    {
      //call the new array function with na's dimensions
      c << getAllocFunc(na->type) << '(';
      for(size_t i = 0; i < na->dims.size(); i++)
      {
        generateExpression(c, na->dims[i]);
        if(i != na->dims.size() - 1)
          c << ", ";
      }
      c << ')';
    }
    else if(auto se = dynamic_cast<SubroutineExpr*>(expr))
    {
      if(se->thisObject)
      {
        INTERNAL_ERROR; //TODO
        /*
        //method call: if this is an lvalue, take its address directly and call
        //if this is not an lvalue, generate a temp copy of it so its address can be taken
        //and use that to generate this ptr
        string thisTemp = getIdentifier();
        c << "{\n" << types[se->thisObject->type] << " temp_ = ";
        generateExpression(c, se->thisObject);
        c << ";\n";
        */
      }
      else
      {
        //standalone call, just emit name of subroutine
        c << subrs[se->subr];
      }
    }
    else if(StructMem* sm = dynamic_cast<StructMem*>(expr))
    {
      c << '(';
      generateExpression(c, sm->base);
      c << ").mem";
      //find index of sm->member
      int memIndex = -1;
      StructType* st = (StructType*) sm->base->type;
      for(size_t i = 0; i < st->members.size(); i++)
      {
        if(sm->member == st->members[i])
        {
          memIndex = i;
          break;
        }
      }
      c << memIndex;
    }
    else if(dynamic_cast<ErrorVal*>(expr))
    {
      INTERNAL_ERROR;
    }
    else if(ArrayLength* al = dynamic_cast<ArrayLength*>(expr))
    {
      c << '(';
      generateExpression(c, al->array);
      c << ").dim";
    }
    else if(TempVar* tv = dynamic_cast<TempVar*>(expr))
    {
      //in C code, this is just the temporary variable's name
      c << tv->ident;
    }
    else
    {
      //compound literal, or anything else that hasn't been covered
      cout << "*** ERROR: generateExpression not implemented for expr subclass : " << typeid(expr).name() << '\n';
      INTERNAL_ERROR;
    }
  }

  void generateBlock(ostream& c, Block* b)
  {
    c << "{\n";
    //introduce local variables
    generateLocalVariables(c, b->scope);
    for(auto blockStmt : b->stmts)
    {
      generateStatement(c, b, blockStmt);
    }
    c << "}\n";
  }

  void generateStatement(ostream& c, Block* b, Statement* stmt)
  {
    //get the type of statement
    if(Block* blk = dynamic_cast<Block*>(stmt))
    {
      generateBlock(c, blk);
    }
    else if(Assign* a = dynamic_cast<Assign*>(stmt))
    {
      generateAssignment(c, b, a->lvalue, a->rvalue);
    }
    else if(CallStmt* cs = dynamic_cast<CallStmt*>(stmt))
    {
      //simply generate the expression and put a semicolon after it
      generateExpression(c, cs->eval);
      c << ";\n";
    }
    else if(For* f = dynamic_cast<For*>(stmt))
    {
      //open a C block for loop scope's vars
      c << "{\n";
      generateLocalVariables(c, f->loopBlock->scope);
      if(f->init)
      {
        generateStatement(c, b, f->init);
      }
      //generate a while loop
      c << "while(";
      if(f->condition)
      {
        generateExpression(c, f->condition);
      }
      else
      {
        c << '1';
      }
      c << ")\n{\n";
      //generate loop body statements
      for(auto loopStmt : f->loopBlock->stmts)
      {
        generateStatement(c, b, loopStmt);
      }
      if(f->increment)
      {
        //enclose increment statement in a block so that
        //the automatic semicolon is OK
        generateStatement(c, b, f->increment);
      }
      c << "}\n}\n";
    }
    else if(While* w = dynamic_cast<While*>(stmt))
    {
      c << "while(";
      generateExpression(c, w->condition);
      c << ")\n";
      c << "{\n";
      generateBlock(c, w->loopBlock);
      c << "}\n";
    }
    else if(If* ii = dynamic_cast<If*>(stmt))
    {
      c << "if(";
      generateExpression(c, ii->condition);
      c << ")\n{\n";
      generateStatement(c, b, ii->body);
      c << "}\n";
    }
    else if(IfElse* ie = dynamic_cast<IfElse*>(stmt))
    {
      c << "if(";
      generateExpression(c, ie->condition);
      c << ")\n";
      generateStatement(c, b, ie->trueBody);
      c << "else\n";
      generateStatement(c, b, ie->falseBody);
    }
    else if(Return* r = dynamic_cast<Return*>(stmt))
    {
      if(r->value)
      {
        c << "return ";
        generateExpression(c, r->value);
        c << ";\n";
      }
      else
      {
        c << "return;\n";
      }
    }
    else if(dynamic_cast<Break*>(stmt))
    {
      c << "break;\n";
    }
    else if(dynamic_cast<Continue*>(stmt))
    {
      c << "continue;\n";
    }
    else if(Print* p = dynamic_cast<Print*>(stmt))
    {
      for(size_t i = 0; i < p->exprs.size(); i++)
      {
        c << getPrintFunc(p->exprs[i]->type) << '(';
        generateExpression(c, p->exprs[i]);
        c << ");\n";
      }
    }
    else if(Assertion* assertion = dynamic_cast<Assertion*>(stmt))
    {
      c << "if(";
      generateExpression(c, assertion->asserted);
      c << ")\n";
      c << "{\n";
      c << "puts(\"Assertion failed.\");\n";
      c << "exit(1);\n";
      c << "}\n";
    }
  }

  void generateAssignment(ostream& c, Block* b, Expression* lhs, Expression* rhs)
  {
    //generateExpression can't be used with compound literals, so
    //  any case where LHS and/or RHS are compound literals needs to be handled separately
    //LHS is compound literal:
    //  -RHS can be another compound lit, or anything else is tuple, struct
    //LHS is variable or indexed:
    //  -RHS can be anything that matches type
    if(dynamic_cast<CallExpr*>(rhs))
    {
      //regardless of the types of lhs and rhs,
      //make sure subroutine only gets called once by saving return value
      c << "{\n";
      string tempName = getIdentifier();
      TempVar temp(tempName, lhs->type, b->scope);
      //now assign temp to lhs
      generateAssignment(c, b, lhs, &temp);
      c << "}\n";
    }
    else if(auto clLHS = dynamic_cast<CompoundLiteral*>(lhs))
    {
      //only compound literals, tuples and structs may be assigned to a compound literal
      if(auto clRHS = dynamic_cast<CompoundLiteral*>(rhs))
      {
        //copy members directly, one at a time
        for(size_t i = 0; i < clLHS->members.size(); i++)
        {
          generateAssignment(c, b, clLHS->members[i], clRHS->members[i]);
        }
      }
      else if(rhs->type->isTuple())
      {
        for(size_t i = 0; i < clLHS->members.size(); i++)
        {
          //create tuple index
          IntLiteral index(i);
          Indexed rhsMember(rhs, &index);
          generateAssignment(c, b, clLHS->members[i], &rhsMember);
        }
      }
      else if(rhs->type->isStruct())
      {
        //generate assignment for each member
        for(size_t i = 0; i < clLHS->members.size(); i++)
        {
          IntLiteral index(i);
          Indexed rhsMember(rhs, &index);
          generateAssignment(c, b, clLHS->members[i], &rhsMember);
        }
      }
    }
    else if(auto clRHS = dynamic_cast<CompoundLiteral*>(rhs))
    {
      //lhs may be a tuple, struct or array
      //know that lhs is not also a compound literal,
      //because that case is handled above
      if(lhs->type->isStruct())
      {
        //generate a StructMem expr for each member,
        //then generate the assignment to that
        //
        //semantic checking has already made sure that
        //compound lit members match 1-1 with struct members
        for(size_t i = 0; i < clRHS->members.size(); i++)
        {
          auto st = dynamic_cast<StructType*>(lhs->type);
          StructMem lhsMem(lhs, st->members[i]);
          generateAssignment(c, b, &lhsMem, clRHS->members[i]);
        }
      }
      else if(lhs->type->isTuple())
      {
        for(size_t i = 0; i < clRHS->members.size(); i++)
        {
          IntLiteral index(i);
          Indexed lhsMember(lhs, &index);
          generateAssignment(c, b, &index, clRHS->members[i]);
        }
      }
      else if(lhs->type->isArray())
      {
        //since an array is an lvalue, it
        //must already be allocated
        /*
        c << getDeallocFunc(lhs->type) << "(";
        generateExpression(c, lhs);
        c << ");\n";
        */
        //create the array with proper size,
        //then assign each element individually
        generateExpression(c, lhs);
        c << " = " << getAllocFunc(lhs->type) << "(";
        c << clRHS->members.size() << ");\n";
        for(size_t i = 0; i < clRHS->members.size(); i++)
        {
          IntLiteral index(i);
          Indexed lhsMember(lhs, &index);
          generateAssignment(c, b, &lhsMember, clRHS->members[i]);
        }
      }
    }
    else
    {
      //direct assignment of one expression to another, where neither
      //lhs nor rhs are CompoundLiterals and rhs is not a subroutine call
      //  -call free on lhs before assignment (if necessary for its type)
      //  -if rhs is assignable, it is persistent, so need to deep copy
      //  -if rhs is not persistent, can shallow copy it
      /*
      if(lhs->assignable() && needsDealloc[lhs->type])
      {
        c << getDeallocFunc(lhs->type) << "(";
        generateExpression(c, lhs);
        c << ");\n";
      }
      */
      if(rhs->assignable())
      {
        generateExpression(c, lhs);
        c << " = " << getCopyFunc(rhs->type) << "(";
        generateExpression(c, rhs);
        c << ");\n";
      }
      else
      {
        generateExpression(c, lhs);
        c << " = ";
        generateExpression(c, rhs);
        c << ";\n";
      }
    }
  }

  void generateLocalVariables(ostream& c, BlockScope* bs)
  {
    for(auto& n : bs->names)
    {
      if(n.second.kind != Name::VARIABLE)
      {
        continue;
      }
      Variable* local = (Variable*) n.second.item;
      string localIdent = getIdentifier();
      vars[local] = localIdent;
      c << types[local->type] << ' ' << localIdent << ";\n";
    }
  }

  void generateInitFuncs()
  {
    for(auto type : types)
    {
      Type* t = type.first;
      string func = getInitFunc(t);
      string typeName = type.second;
      utilFuncDecls << typeName << ' ' << func << "();\n";
      utilFuncDefs << typeName << ' ' << func << "()\n{\n";
      if(t->isNumber() || t->isChar())
      {
        utilFuncDefs << "return 0;\n";
      }
      else if(t->isBool())
      {
        utilFuncDefs << "return false;\n";
      }
      else if(t->isStruct() || t->isTuple())
      {
        auto st = dynamic_cast<StructType*>(t);
        auto tt = dynamic_cast<TupleType*>(t);
        utilFuncDefs << typeName << " temp_;\n";
        if(st)
        {
          for(size_t i = 0; i < st->members.size(); i++)
          {
            utilFuncDefs << "temp_.mem" << i << " = " << getInitFunc(st->members[i]->type) << "();\n";
          }
        }
        else
        {
          for(size_t i = 0; i < tt->members.size(); i++)
          {
            utilFuncDefs << "temp_.mem" << i << " = " << getInitFunc(tt->members[i]) << "();\n";
          }
        }
        utilFuncDefs << "return temp_;\n";
      }
      else if(t->isArray())
      {
        //empty array doesn't need any allocation (leave data null)
        utilFuncDefs << "return ((" << typeName << ") {0, NULL});\n";
      }
      else if(t->isUnion())
      {
        utilFuncDefs << "return ((" << typeName << ") {NULL, 0});\n";
      }
      utilFuncDefs << "}\n";
    }
  }

  void generateCopyFuncs()
  {
    for(auto type : types)
    {
      Type* t = type.first;
      if(t->isVoid())
        continue;
      string& typeName = type.second;
      //only ArrayTypes (and anything containing an array type) require nontrivial copy
      string func = getCopyFunc(t);
      {
        Oss prototype;
        prototype << typeName << ' ' << func << '(' << typeName << " data_)";
        utilFuncDecls << prototype.str() << ";\n";
        utilFuncDefs << prototype.str() << "\n{\n";
      }
      //note: void doesn't get a copy function because it will never be called
      //cannot have variable or argument of type void (checked in middle end)
      if(!t->isVoid() && t->isPrimitive())
      {
        //primitives (integers, bool, are always trivially copyable
        utilFuncDefs << "return data_;\n";
      }
      else if(auto at = dynamic_cast<ArrayType*>(t))
      {
        string& subtype = types[at->subtype];
        utilFuncDefs << subtype << "* temp_ = malloc(sizeof(" << subtype << ") * data_.dim);\n";
        utilFuncDefs << "for(" << size_type << " i_ = 0; i_ < data_.dim; i_++)\n{\n";
        utilFuncDefs << "temp_[i_] = " << getCopyFunc(at->subtype) << "(data_.data[i_]);\n";
        utilFuncDefs << "}\n";
        utilFuncDefs << "return ((" << typeName << ") {data_.dim, temp_});\n";
      }
      else if(auto st = dynamic_cast<StructType*>(t))
      {
        utilFuncDefs << typeName << " temp_;\n";
        for(size_t i = 0; i < st->members.size(); i++)
        {
          utilFuncDefs << "temp_.mem" << i << " = " << getCopyFunc(st->members[i]->type) << "(data_." << st->members[i]->name << ");\n";
        }
        utilFuncDefs << "return temp_;\n";
      }
      else if(auto ut = dynamic_cast<UnionType*>(t))
      {
        utilFuncDefs << typeName << " temp_;\n";
        utilFuncDefs << "temp_.option = data_.option;\n";
        utilFuncDefs << "switch(data_.option)\n";
        for(size_t i = 0; i < ut->options.size(); i++)
        {
          utilFuncDefs << "case " << i << ":\n";
          //allocate space in temp
          string& optionType = types[ut->options[i]];
          utilFuncDefs << "temp_.data = malloc(sizeof(" << optionType << ");\n";
          //deep copy data_'s underlying type into temp_
          utilFuncDefs << "*((" << optionType << "*) temp_.data) = " << getCopyFunc(ut->options[i]) << "(*((" << optionType << "*) data_.data));\n";
          utilFuncDefs << "break;\n";
        }
      }
      else if(auto tt = dynamic_cast<TupleType*>(t))
      {
        //like struct, copy one member at a time
        utilFuncDefs << typeName << " temp_;\n";
        for(size_t i = 0; i < tt->members.size(); i++)
        {
          utilFuncDefs << "temp_.mem" << i << " = " << getCopyFunc(tt->members[i]) << "(data_.mem" << i << ");\n";
        }
        utilFuncDefs << "return temp_;\n";
      }
      utilFuncDefs << "}\n";
    }
  }

  void generateAllocFuncs()
  {
    for(auto type : types)
    {
      if(ArrayType* at = dynamic_cast<ArrayType*>(type.first))
      {
        string typeName = type.second;
        string func = getAllocFunc(at);
        {
          Oss prototype;
          prototype << typeName << ' ' << func << '(' << size_type << " len_)";
          utilFuncDecls << prototype.str();
          utilFuncDecls << ";\n";
          utilFuncDefs << prototype.str();
          utilFuncDefs << "\n{\n";
        }
        //add prototype to both util decls and defs
        //allocate an array of the subtype
        string& subtype = types[at->subtype];
        utilFuncDefs << subtype << "* temp_ = malloc(sizeof(" << subtype << ") * len_);\n";
        utilFuncDefs << "for(size_t i_ = 0; i_ < len_; i_++)\n";
        utilFuncDefs << "temp_[i_] = " << getInitFunc(at->subtype) << "();\n";
        utilFuncDefs << "return ((" << typeName << ") {len_, temp_});\n";
        utilFuncDefs << "}\n";
      }
    }
  }

  bool typeNeedsDealloc(TypeSystem::Type* t)
  {
    //lazily populate needsDealloc
    auto it = needsDealloc.find(t);
    if(it == needsDealloc.end())
    {
      bool value = false;
      if(t->isPrimitive())
      {
        value = false;
      }
      else if(auto st = dynamic_cast<StructType*>(t))
      {
        for(auto mem : st->members)
        {
          if(typeNeedsDealloc(mem->type))
          {
            value = true;
            break;
          }
        }
      }
      else if(auto tt = dynamic_cast<TupleType*>(t))
      {
        for(auto mem : tt->members)
        {
          if(typeNeedsDealloc(mem))
          {
            value = true;
            break;
          }
        }
      }
      else if(dynamic_cast<UnionType*>(t))
      {
        value = true;
      }
      else if(dynamic_cast<ArrayType*>(t))
      {
        value = true;
      }
      needsDealloc[t] = value;
      return value;
    }
    return it->second;
  }

  void generateDeallocFuncs()
  {
    for(auto type : types)
    {
      if(typeNeedsDealloc(type.first))
      {
        auto t = type.first;
        string& typeName = type.second;
        string func = getDeallocFunc(t);
        //only struct, tuple, array and unions need to be freed
        utilFuncDecls << "void " << func << "(" << typeName << " data_);\n";
        utilFuncDefs << "inline void " << func << "(" << typeName << " data_)\n{\n";
        if(auto st = dynamic_cast<StructType*>(t))
        {
          for(size_t i = 0; i < st->members.size(); i++)
          {
            if(typeNeedsDealloc(st->members[i]->type))
            {
              utilFuncDefs << getDeallocFunc(st->members[i]->type) << "(data_." << st->members[i]->type << ");\n";
            }
          }
        }
        else if(auto tt = dynamic_cast<TupleType*>(t))
        {
          for(size_t i = 0; i < tt->members.size(); i++)
          {
            if(typeNeedsDealloc(tt->members[i]))
            {
              utilFuncDefs << getDeallocFunc(tt->members[i]) << "(data_.mem" << i << ");\n";
            }
          }
        }
        else if(auto ut = dynamic_cast<UnionType*>(t))
        {
          utilFuncDefs << "switch(data_.option)\n{\n";
          for(size_t i = 0; i < ut->options.size(); i++)
          {
            utilFuncDefs << "case " << i << ":\n";
            if(typeNeedsDealloc(ut->options[i]))
            {
              utilFuncDefs << getDeallocFunc(ut->options[i]) << "(*((" << types[ut->options[i]] << "*) data_.data));\n";
            }
            utilFuncDefs << "break;\n";
          }
          utilFuncDefs << "free(data_.data);\n";
          utilFuncDefs << "}\n";
        }
        else if(auto at = dynamic_cast<ArrayType*>(t))
        {
          utilFuncDefs << "if(data_.data != NULL)\n{\n";
          //add free calls for each element, if subtype has nontrivial deallocator
          if(typeNeedsDealloc(at->subtype))
          {
            utilFuncDefs << "for(size_t i_ = 0; i_ < data_.dim; i_++)\n{\n";
            utilFuncDefs << getDeallocFunc(at->subtype) << "(data_.data[i_]);\n";
            utilFuncDefs << "}\n";
          }
          utilFuncDefs << "free(data_.data);\n";
          utilFuncDefs << "}\n";
        }
        utilFuncDefs << "}\n";
      }
    }
  }

  void generatePrintFuncs()
  {
    for(auto type : types)
    {
      Type* t = type.first;
      if(t->isVoid())
        continue;
      string& typeName = type.second;
      string func = getPrintFunc(t);
      utilFuncDecls << "void " << func << "(" << typeName << " data_);\n";
      utilFuncDefs << "void " << func << "(" << typeName << " data_)\n{\n";
      if(t->isPrimitive() && !t->isBool())
      {
        //all primitives (except bool) can be printed as a printf call with a single %
        //so just determine the %format
        string fmt;
        if(auto intType = dynamic_cast<IntegerType*>(t))
        {
          //printf format code
          switch(intType->size)
          {
            case 1:
              fmt = intType->isSigned ? "hhd" : "hhu";
              break;
            case 2:
              fmt = intType->isSigned ? "hd" : "hu";
              break;
            case 4:
              fmt = intType->isSigned ? "d" : "u";
              break;
            case 8:
              fmt = intType->isSigned ? "lld" : "llu";
              break;
            default:
              INTERNAL_ERROR;
          }
        }
        else if(t->isChar())
        {
          fmt = "c";
        }
        else if(t->isFloat())
        {
          fmt = "f";
        }
        utilFuncDefs << "printf(\"%" << fmt << "\", data_);\n";
      }
      else if(t->isBool())
      {
        utilFuncDefs << "if(data_)\nprintf(\"true\");\nelse\nprintf(\"false\");\n";
      }
      else
      {
        //compound types
        if(ArrayType* at = dynamic_cast<ArrayType*>(t))
        {
          if(at->subtype->isChar())
          {
            //t is string, so write it to stdout all at once
            utilFuncDefs << "fwrite(data_.data, 1, data_.dim, stdout);\n";
          }
          else
          {
            utilFuncDefs << "putchar('{');\n";
            utilFuncDefs << "for(uint64_t count_ = 0; ";
            utilFuncDefs << "count_ < data_.dim; count_++)\n{\n";
            utilFuncDefs << getPrintFunc(at->subtype) << "(data_.data[count_]);\n}\n";
            utilFuncDefs << "putchar('}');\n";
          }
        }
        else if(TupleType* tt = dynamic_cast<TupleType*>(t))
        {
          utilFuncDefs << "putchar('(');\n";
          //print each member, comma separated
          for(size_t i = 0; i < tt->members.size(); i++)
          {
            utilFuncDefs << getPrintFunc(tt->members[i]) << "(data_.mem" << i << ");\n";
            if(i != tt->members.size() - 1)
            {
              utilFuncDefs << "printf(\", \");\n";
            }
          }
          utilFuncDefs << "putchar(')');\n";
        }
        else if(StructType* st = dynamic_cast<StructType*>(t))
        {
          utilFuncDefs << "printf(\"" << st->getName() << " {\");\n";
          //print each member, comma separated
          for(size_t i = 0; i < st->members.size(); i++)
          {
            utilFuncDefs << getPrintFunc(st->members[i]->type) << "(data_.mem" << i << ");\n";
            if(i != st->members.size() - 1)
            {
              utilFuncDefs << "printf(\", \");\n";
            }
          }
          utilFuncDefs << "putchar(')');\n";
        }
        else if(UnionType* ut = dynamic_cast<UnionType*>(t))
        {
          utilFuncDefs << "printf(\"" << ut->getName() << " @%i\", data_.option);\n";
          utilFuncDefs << "switch(data_.option)\n{\n";
          for(size_t i = 0; i < ut->options.size(); i++)
          {
            utilFuncDefs << "case " << i << ":\n";
            utilFuncDefs << getPrintFunc(ut->options[i]) << "(*((" << types[ut->options[i]] << ") data_.data));\n";
            utilFuncDefs << "break;\n";
          }
          utilFuncDefs << "default:;\n";
          utilFuncDefs << "}\n";
        }
      }
      utilFuncDefs << "}\n";
    }
  }

  string getIdentifier()
  {
    //use a base-36 encoding of identCount using 0-9 A-Z
    char buf[32];
    buf[31] = 0;
    auto val = identCount;
    int iter = 30;
    for(;; iter--)
    {
      int digit = val % 36;
      if(digit < 10)
      {
        buf[iter] = '0' + digit;
      }
      else
      {
        buf[iter] = 'A' + (digit - 10);
      }
      val /= 36;
      if(val == 0)
        break;
    }
    //now buf + iter is the string
    identCount++;
    return string("o") + (buf + iter) + '_';
  }

  template<typename F>
  void walkScopeTree(F f)
  {
    vector<Scope*> visit;
    visit.push_back(global);
    while(visit.size())
    {
      Scope* s = visit.back();
      f(s);
      visit.pop_back();
      for(auto child : s->children)
      {
        visit.push_back(child);
      }
    }
  }

  void generateCompoundType(ostream& c, string cName, TypeSystem::Type* t)
  {
    auto at = dynamic_cast<ArrayType*>(t);
    auto st = dynamic_cast<StructType*>(t);
    auto ut = dynamic_cast<UnionType*>(t);
    auto tt = dynamic_cast<TupleType*>(t);
    auto et = dynamic_cast<EnumType*>(t);
    //first, make sure all necessary types have already been defined
    //this can't cause infinite recursion because semantic
    //checker makes sure there is no circular members
    if(at)
    {
      if(!typesImplemented[at->elem])
      {
        generateCompoundType(c, types[at->elem], at->elem);
      }
    }
    else if(st)
    {
      for(auto mem : st->members)
      {
        if(!typesImplemented[mem->type])
        {
          generateCompoundType(c, types[mem->type], mem->type);
        }
      }
    }
    else if(tt)
    {
      for(auto mem : tt->members)
      {
        if(!typesImplemented[mem])
        {
          generateCompoundType(c, types[mem], mem);
        }
      }
    }
    if(et)
    {
      //enum type always represented as signed integer, which is as
      //small as possible while still fitting all values
      c << "typedef int" << 8 * et->bytes << "_t " << cName << ";\n";
    }
    else
    {
      //open a struct declaration
      c << "struct " << cName << "\n{\n";
      if(at)
      {
        //add dims
        c << size_type << " dim;\n";
        //add pointer to element type
        c << types[at->subtype] << "* data;\n";
      }
      else if(st)
      {
        //add all members (as pointer)
        //  since there is no possible name collision among the member names, don't
        //  need to replace them with mangled identifiers
        for(size_t i = 0; i < st->members.size(); i++)
        {
          c << types[st->members[i]->type] << " mem" << i << ";\n";
        }
      }
      else if(ut)
      {
        c << "void* data;\n";
        c << "int option;\n";
      }
      else if(tt)
      {
        for(size_t i = 0; i < tt->members.size(); i++)
        {
          //tuple members are anonymous so just use memN as the name
          c << types[tt->members[i]] << " mem" << i << ";\n";
        }
      }
      c << "};\n";
    }
    typesImplemented[t] = true;
  }

  string getPrintFunc(Type* t)
  {
    return "print_" + types[t] + "_";
  }

  string getInitFunc(Type* t)
  {
    return "init_" + types[t] + "_";
  }

  string getCopyFunc(Type* t)
  {
    return "copy_" + types[t] + "_";
  }

  string getAllocFunc(Type* t)
  {
    return "alloc_" + types[t] + "_";
  }

  string getDeallocFunc(TypeSystem::Type* t)
  {
    return "free_" + types[t] + "_";
  }

  void generateSectionHeader(ostream& c, string name)
  {
    c << "//////////////////////////////\n";
    int space = 13 - name.length() / 2;
    c << "//";
    for(int i = 0; i < space; i++)
      c << ' ';
    c << name;
    for(int i = 2 + space + name.length(); i < 28; i++)
      c << ' ';
    c << "//\n";
    c << "//////////////////////////////\n\n";
  }
}

