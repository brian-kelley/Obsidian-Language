#include "CppGen.hpp"

void generateCPP(string outputStem, bool keep, string& code)
{
  string cppName;
  if(keep)
  {
    cppName = outputStem + ".cpp";
  }
  else
  {
    cppName = "temp.cpp";
  }
  string exeName = outputStem + ".exe";
  FILE* cpp = fopen(cppName.c_str(), "wb");
  if(!cpp)
  {
    errAndQuit("Failed to open CPP file for writing.");
  }
  fprintf(cpp, "// ---%s, generated by the Obsidian Compiler ---//\n\n", cppName.c_str());
  generateTypeHeader(cpp, code);
  generateFuncHeader(cpp, code);
  fclose(cpp);
  //! feed into g++
  puts("*** Running g++ ***");
  string cmd = string("g++ ") + cppName + " --std=c++11 -o " + exeName;
  system(cmd.c_str());
  if(!keep)
  {
    remove(cppName.c_str());
  }
}

void generateTypeHeader(FILE* cpp, string& code)
{
  //For each type, generate a typedef
  //Primitive plain old data are first in the type table so they will always be available
  //do not redefine already existing c++ primitives (int, char...)
  //all types are otherwise defined in type table order
  for(Type* t : Type::table)
  {
    if(t->isPOD())
    {
      PodType* pod = (PodType*) t;
      if(pod->name == "char" || pod->name == "short" || pod->name == "int" || pod->name == "long")
        continue;
      fprintf(cpp, "typedef %s %s;\n", (pod->getCppName()).c_str(), pod->name.c_str());
    }
    else if(t->fixedSize() && t->isArray())
    {
      FixedArrayType* arr = (FixedArrayType*) t;
      //make a simple struct with fixed-size array as only member
      fprintf(cpp, "typedef struct %s {\n", t->name.c_str());
      fprintf(cpp, "  %s elems[%i]; }\n", arr->elems->name.c_str(), arr->n);
    }
    else if(t->isStruct() && t->fixedSize())
    {
      StructType* st = (StructType*) t;
      fprintf(cpp, "typedef struct %s {\n", t->name.c_str());
      //write type/name of each member
      //TODO: handle alignment robustly
      for(size_t i = 0; i < st->memTypes.size(); i++)
      {
        fprintf(cpp, "  %s %s;\n", st->memTypes[i]->name.c_str(), st->memNames[i].c_str());
      }
      fputs("}\n", cpp);
    }
  }
}

void generateFuncHeader(FILE* cpp, string& code)
{

}

void compileCPP(string cppSrc, string output)
{

}
