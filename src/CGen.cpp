#include "CGen.hpp"

void generateC(string outputStem, bool keep, string& code)
{
  string cName;
  if(keep)
  {
    cName = outputStem + ".c";
  }
  else
  {
    cName = "temp.c";
  }
  string exeName = outputStem + ".exe";
  FILE* c = fopen(cName.c_str(), "wb");
  if(!c)
  {
    errAndQuit("Failed to open C file for writing.");
  }
  fprintf(c, "// ---%s, generated by the Obsidian Compiler ---//\n\n", cName.c_str());
  generateTypeHeader(c, code);
  generateFuncHeader(c, code);
  fclose(c);
  //! feed into gcc
  puts("*** Running gcc ***");
  string cmd = string("gcc ") + cName + " --std=c11 -o " + exeName;
  system(cmd.c_str());
  if(!keep)
  {
    remove(cName.c_str());
  }
}

void generateTypeHeader(FILE* c, string& code)
{
  //For each type, generate a typedef
  //Primitive plain old data are first in the type table so they will always be available
  //do not redefine already existing c++ primitives (int, char...)
  //all types are otherwise defined in type table order
  for(Type* t : Type::table)
  {
    if(t->isPOD())
    {
      PodType* pod = (PodType*) t;
      if(pod->name == "char" || pod->name == "short" || pod->name == "int" || pod->name == "long")
        continue;
      fprintf(c, "typedef %s %s;\n", (pod->getCppName()).c_str(), pod->name.c_str());
    }
    else if(t->fixedSize() && t->isArray())
    {
      FixedArrayType* arr = (FixedArrayType*) t;
      //make a simple struct with fixed-size array as only member
      fprintf(c, "typedef struct %s {\n", t->name.c_str());
      fprintf(c, "  %s elems[%i]; }\n", arr->elems->name.c_str(), arr->n);
    }
    else if(t->isStruct() && t->fixedSize())
    {
      StructType* st = (StructType*) t;
      fprintf(c, "typedef struct %s {\n", t->name.c_str());
      //write type/name of each member
      //TODO: handle alignment robustly
      for(size_t i = 0; i < st->memTypes.size(); i++)
      {
        fprintf(c, "  %s %s;\n", st->memTypes[i]->name.c_str(), st->memNames[i].c_str());
      }
      fputs("}\n", c);
    }
  }
}

void generateFuncHeader(FILE* c, Program& prog)
{

}

void generateCode(FILE* c, Program& prog)
{
}

